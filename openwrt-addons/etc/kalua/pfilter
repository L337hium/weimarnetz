# tc qdisc add dev eth0 root handle 1: cbq avpkt 1000 bandwidth [HN]
# tc qdisc show

# idea! for splashed people:
# iptables -I INPUT -p tcp --dport 80 -m limit --limit 1/sec --limit-burst 1 -j ACCEPT

_ipt ()		# for better logging and safer installing - have seen strange errors during iptables-insert-storms
{
	local LOCKFILE="/tmp/iptables_lock"

	while [ -e "$LOCKFILE" ]; do {		# fixme! make a trap()
		if _watch counter "/tmp/iptables_lockfile_counter" increment 1 max 60 ; then
			_log do iptables_wrapper daemon info "waiting till lockfile $LOCKFILE is gone, pid $$"
			sleep "$( _math random_integer 1 5 )"
		else
			_log do iptables_wrapper daemon alert "detected race, deleting lockfile"
			rm "$LOCKFILE"
			break
		fi
	} done

	touch "$LOCKFILE"
	_watch counter "/tmp/iptables_lockfile_counter" set 1

	local FUNC="iptables"
	local ARGS="$1 $2 $3 $4 $5 $6 $7 $8 $9 ${10} ${11} ${12} ${13} ${14} ${15} ${16} ${17} ${18} ${19} ${20}"
	local ERRORFILE="/tmp/iptables_$$"
	local LINE CLEANUP MATCH JUMP FILE BUILTIN=""

	# idea: *--l7proto*) detect this?

# /lib/modules/2.4.30/ipt_DSCP.o
# /lib/modules/2.4.30/ipt_ECN.o
# /lib/modules/2.4.30/ipt_MIRROR.o
# /lib/modules/2.4.30/ipt_TARPIT.o
# /lib/modules/2.4.30/ipt_TOS.o
# /lib/modules/2.4.30/ipt_TTL.o
# /lib/modules/2.4.30/ipt_ah.o
# /lib/modules/2.4.30/ipt_dscp.o
# /lib/modules/2.4.30/ipt_ecn.o
# /lib/modules/2.4.30/ipt_esp.o
# /lib/modules/2.4.30/ipt_helper.o		# match conntrack-tracked conns by string
# /lib/modules/2.4.30/ipt_owner.o
# /lib/modules/2.4.30/ipt_physdev.o
# /lib/modules/2.4.30/ipt_pkttype.o
# /lib/modules/2.4.30/ipt_recent.o
# /lib/modules/2.4.30/ipt_string.o
# /lib/modules/2.4.30/ipt_tcpmss.o
# /lib/modules/2.4.30/ipt_tos.o
# /lib/modules/2.4.30/ipt_unclean.o

# /usr/lib/iptables/libipt_*	// kernel 2.4
# /usr/lib/iptables/libxt_*	// kernel 2.6
# joined: /usr/lib/iptables/lib*_*

	case "$ARGS" in
		*\ -m\ *)
			MATCH="$( echo "$ARGS" | sed -n 's/^.* -m \([a-z0-9]*\) .*/\1/p' )"

			[ -n "$MATCH" -a ! -e /tmp/iptables_match_$MATCH ] && {

				FILE="/usr/lib/iptables/lib*_${MATCH}.so"

				_log do $FUNC daemon debug "detected match '$MATCH' for first time"
				touch /tmp/iptables_match_$MATCH
			
				case "$MATCH" in
					conntrack|connlimit|connmark|connbytes|udplimit|length|layer7|ipp2p|ttl)
						_system insmod ipt_$MATCH
					;;
					state|limit|mac|mark|multiport)
						:
					;;
					*)
						_log do $FUNC daemon debug "uncatched match"
					;;
				esac
				
				if [ -e $FILE ]; then
					_log do $FUNC daemon debug "match '$MATCH' exists and is automatically loaded (or builtin)"
				else
					_log do $FUNC daemon debug "match '$MATCH' does not exist ('$FILE')"
				fi
			}
		;;
	esac
	
	case "$ARGS" in
		*\ -j\ *)	
			JUMP="$( echo "$ARGS" | sed -n 's/^.* -j \([A-Z]*\).*/\1/p' )"		# fixme! custom chains can be [a-z]

			[ -n "$JUMP" -a ! -e /tmp/iptables_jump_$JUMP ] && {
	
				FILE="/usr/lib/iptables/lib*_${JUMP}.so"
	
				_log do $FUNC daemon debug "detected jump '$JUMP' for first time"
				touch /tmp/iptables_jump_${JUMP}
	
				case "$JUMP" in
					CONNMARK|CLASSIFY|ULOG|REDIRECT)
						_system insmod ipt_$JUMP
					;;
					ACCEPT|DROP|LOG|MASQUERADE|RETURN)
						BUILTIN=1
					;;
					REJECT|MARK|TCPMSS)
						:
					;;
					*)
						if iptables -nL $JUMP >/dev/null ; then
							_log do $FUNC daemon debug "custom chain '$JUMP'"
						else
							_log do $FUNC daemon debug "uncatched jump '$JUMP'"
						fi
					;;
				esac
				
				if [ -e $FILE -o "$BUILTIN" = "1" ]; then
					_log do $FUNC daemon debug "jump '$JUMP' exists and is automatically loaded (or builtin)"
				else
					_log do $FUNC daemon debug "jump '$JUMP' does not exist ('$FILE')"
				fi
			}
		;;
	esac
	
	iptables $ARGS 2>$ERRORFILE || {
		_log do $FUNC daemon debug "something went wrong: '$ARGS' - retry"
		sleep 1
		iptables $ARGS 2>$ERRORFILE || {
			_log do $FUNC daemon info "giving up: '$ARGS'"
			CLEANUP=1
		}
	}

	[ -e $ERRORFILE ] && {
		while read LINE; do {
			_log do $FUNC daemon info "former error: '$LINE' (ARGS: '$ARGS')"
			
			case "$LINE" in
				"iptables: No chain/target/match by that name")
					_log do $FUNC daemon info "trap reached"	# fixme! try to list chain?
				;;
			esac
			
		} done <$ERRORFILE

		rm $ERRORFILE
	}
		
	rm $LOCKFILE
	return ${CLEANUP:-0}
}

_pfilter_status ()
{
	local funcname="pfilter_status"
	local command="$1"
	local statusfile="/tmp/USER_PACKETFILTER"

	case "$command" in
		mark_down)
			if [ -e "$statusfile" ]; then
				_log do $funcname daemon info "mark_down (first time)"
				rm "$statusfile"
			else
				_log do $funcname daemon info "mark_down (already marked)"
			fi
		;;
		mark_up)
			if [ -e "$statusfile" ]; then
				_log do $funcname daemon info "mark_up (already marked)"
			else
				_log do $funcname daemon info "mark_up (first time)"
				touch "$statusfile"
			fi
		;;
		is_up)
			if [ -e "$statusfile" ]; then
				return 0
			else
				return 1
			fi
		;;
	esac
}

_pfilter_user_splash_remove ()
{
	local func="pfilter_user_splash_remove"
	local jobfile="/tmp/USER_PACKETFILTER_jobs"
	local MAC="$1"
	local IP="$2"
	local job_control="$3"

	[ -z "$MAC" -o -z "$IP" ] && {
		return 1
	}

	case "$job_control" in
		work)
			continue
		;;
		do_pending_jobs)
			if [ -e "$jobfile" ]; then
				_log do $func daemon info "[START] working on jobs in $jobfile"

				. "$jobfile"
				rm "$jobfile"

				_log do $func daemon info "[READY] working on jobs in $jobfile"
			else
				_log do $func daemon info "[OK] no pending jobs found in $jobfile"
			fi

			return
		;;
		*)
			_pfilter status is_up || {
				_log do $func daemon info "packetfilter not up yet, scheduling job in $jobfile"

				fgrep -s -q "$MAC $IP work" "$jobfile" || {
					echo "_pfilter user_splash_remove $MAC $IP work" >>"$jobfile"
				}

				return
			}
		;;
	esac
								# user is known, but splashed
	_pfilter user_list | grep -q -i $MAC && {
		_pfilter user_splash_control nosplash "$MAC" "$IP" >/dev/null
		return
	}

	_pfilter user_ruleset_activate $MAC $IP || {		# user is new and splashed
		_pfilter user_add $MAC $IP
	}
}

_pfilter_rules_remove_all_masquerading()		# fixme! is a hack
{
	local funcname="pfilter_rules_remove_all_masquerading"

	masq_rules_exist()
	{
		iptables -t nat -nL POSTROUTING | fgrep -q MASQUERADE
	}

	linenumber_first_masq_rule()
	{
		iptables --line-numbers -t nat -nL POSTROUTING |
		 fgrep MASQUERADE |
		  head -n1 |
		   cut -d' ' -f1
	}

	while masq_rules_exist ; do {
		_log do $funcname daemon info "removing a masq-rule"
		iptables -t nat -D POSTROUTING $( linenumber_first_masq_rule )
	} done
}

_pfilter_rules_webserver_deny_incoming_nonlocal ()
{
	local FUNC="pfilter_rules_webserver_deny_incoming_nonlocal"
	local MYHNA="$( uci get olsrd.@Hna4[0].netaddr )/$( _net mask2cidr $( uci get olsrd.@Hna4[0].netmask ) )"
	
	_log do $FUNC daemon info "activate blocking for HTTP(S) to avoid lowmem situations during software-install"

	_ipt -I INPUT -p tcp ! -s $MYHNA  --dport  80 -j DROP		# if REJECT is not possible, then method DROP is fallback
	_ipt -I INPUT -p tcp ! -s $MYHNA  --dport 443 -j DROP

	_ipt -I INPUT -p tcp ! -s $MYHNA  --dport  80 -j REJECT
	_ipt -I INPUT -p tcp ! -s $MYHNA  --dport 443 -j REJECT

	_ipt -I INPUT -p tcp -s 127.0.0.1 --dport  80 -j ACCEPT
	_ipt -I INPUT -p tcp -s 127.0.0.1 --dport 443 -j ACCEPT
}

_pfilter_user_ruleset_activate ()
{
	local FUNC="pfilter_user_ruleset_activate"
	local MAC_RESERVE
	local MAC_RESERVE_LIST="99:99:99:99:99:99 99:99:99:99:99:98 99:99:99:99:99:97 99:99:99:99:99:96 99:99:99:99:99:95"
	local MAC="$1"
	local IP="$2"

	for MAC_RESERVE in $MAC_RESERVE_LIST; do {

		iptables -t mangle -E traff_${MAC_RESERVE} traff_$MAC 2>/dev/null && { 			# fixme! how to use _ipt()
	
			_log do $FUNC daemon info "found chain traff_${MAC_RESERVE} and renamed to 'traff_$MAC'"
			
			_ipt -t mangle -D traff_users -m mac --mac-source $MAC_RESERVE	-j traff_$MAC
			_ipt -t mangle -D traff_users -d 99.99.99.99			-j traff_$MAC

			_ipt -t mangle -D traff_$MAC 12
			_ipt -t mangle -I traff_$MAC 12 -m mark --mark $( _pfilter proto2id CONN )/0xFF -j ULOG --ulog-prefix "${MAC}>"	# inside2outside
			_ipt -t mangle -D traff_$MAC 19
			_ipt -t mangle -I traff_$MAC 19 -m mark --mark $( _pfilter proto2id CONN )/0xFF -j ULOG --ulog-prefix "${MAC}<"	# outside2inside

			iptables -t mangle -nL traff_users | grep -q ^traff_$MAC || {
				_ipt -t mangle -A traff_users -m mac --mac-source $MAC	-j traff_$MAC
				_ipt -t mangle -A traff_users -d $IP			-j traff_$MAC
			}

			_net arp_permanent $IP $MAC
			_pfilter user_splash_control nosplash "$MAC" "$IP"
		
			_log do $FUNC daemon info "successfully activated 'traff_$MAC'"

			_scheduler add "/etc/local.fw-fff+ adduser_reserve $MAC_RESERVE 99.99.99.99"
			return 0
		}

		_log do $FUNC daemon debug "renaming chain 'traff_${MAC_RESERVE}' to 'traff_$MAC' didn't work"
		_scheduler add "/etc/local.fw-fff+ adduser_reserve $MAC_RESERVE 99.99.99.99"
		
		[ "$MAC_RESERVE" = "99:99:99:99:99:95" ] && {
			_pfilter status is_up || {
				_scheduler add "/etc/local.fw-fff+ close_doors"
			}
		}
	} done
	
	return 1
}

_pfilter_stats_simple_approach ()
{
	return 0			# fixme!
}

_pfilter_stats_p2p_block ()
{
	local PROFILE="$( uci get system.@profile[0].name )"

	case $PROFILE in
		weimarnetz) return 0 ;;
			 *) return 1 ;;
	esac
}

_pfilter_stats_rules_count ()
{
	local LIST="${1:-mangle filter nat}"
	local OPTION="$2"			# POSTROUTING
	local TABLE COUNT
	
	for TABLE in $LIST; do {
		COUNT="$( iptables -t $TABLE -nxL $OPTION | sed -e '/^target/d' -e '/^Chain /d' -ne '/[^.]$/p' | sed -n '$=' )"
		_log do packetfilter_count_rules daemon debug "$COUNT rules in '$TABLE' $OPTION"
	} done
}

_pfilter_rules_portfw_install ()
{
	local FUNC="pfilter_rules_portfw_install"
	local ENTRY
	local PROTO
	local PORTFORWARDING="$( uci get firewall.@portfw[0].portfw )"
	local MYHNA="$( uci get olsrd.@Hna4[0].netaddr )/$( _net mask2cidr $( uci get olsrd.@Hna4[0].netmask ) )"
	local statfile="/tmp/$FUNC"

	for ENTRY in $PORTFORWARDING; do {

		eval $( _pfilter rules_portfw_config_serialize $ENTRY )

		[ $RULE_ACTIVE = "on" ] && {

			[ -e "$statfile" ] || {
				_ipt -I FORWARD -i $WANDEV -d $MYHNA -j ACCEPT		# fixme! this overrides some important FORWARD rules (tcpmss etc.)
				touch "$statfile"
			}

			case $RULE_INCOMING_INTERFACE in
				 wan) RULE_INCOMING_INTERFACE="-i $WANDEV"	;;
				 lan) RULE_INCOMING_INTERFACE="-i $LANDEV"	;;
				wifi) RULE_INCOMING_INTERFACE="-i $WIFIDEV"	;;
			     tun|tap) RULE_INCOMING_INTERFACE="-i ${RULE_INCOMING_INTERFACE}+" ;;
				   *) RULE_INCOMING_INTERFACE=""		;;
			esac

			[ $RULE_DEST_IP = "me" ] && RULE_DEST_IP=		# this works!
			[ $RULE_PROTO = "both" ] && RULE_PROTO="tcp udp"

			for PROTO in $RULE_PROTO; do {

				RULE_ACTIVE="-t nat -I PREROUTING $RULE_INCOMING_INTERFACE -p $PROTO --dport $RULE_PORT_INCOMING -j DNAT --to-destination $RULE_DEST_IP:$RULE_PORT_DEST"

					if _ipt $RULE_ACTIVE ; then
				     		_log do $FUNC user info "success adding rule '$RULE_NAME'"
				     	else
				     		_log do $FUNC user err  "error adding rule '$ENTRY' ('_ipt $RULE_ACTIVE')"
				     	fi
			} done
		}
	} done
}

_pfilter_rules_dhcp_ignore_specific_macs ()	# SENS: mario
{
	local FUNC="pfilter_rules_dhcp_ignore_specific_macs"
	local MAC
	
	for MAC in $( uci get firewall.@ignoredhcp[0].mac ); do {		# format: 'MAC1 MAC2 MACn"

		_log do $FUNC daemon debug "ignoring '$MAC'"
		_ipt -I INPUT -p udp --sport 68 -d 255.255.255.255 --dport 67 -m mac --mac-source $MAC -j DROP
	} done
}

_pfilter_rules_portfw_config_serialize ()
{
	# like in DD-WRT (but with incoming interface!)

	# name:active:incoming_interface:proto:dport>dest_ip:dest_port name:...
	# name:on/off:any/wan/lan/wifi:tcp/udp/both:dport>dest_ip:dest_port name:...

	# emule:off:wan:both:4661>10.63.45.100:4661
	# webcam:on:any:tcp:8080>10.63.168.97:80
	# myssh:on:wan:tcp:10022>me:22
	
	echo $1 | sed 's/\(.*\):\(.*\):\(.*\):\(.*\):\(.*\)>\(.*\):\(.*\)/local RULE_NAME=\1\nlocal RULE_ACTIVE=\2\nlocal RULE_INCOMING_INTERFACE=\3\nlocal RULE_PROTO=\4\nlocal RULE_PORT_INCOMING=\5\nlocal RULE_DEST_IP=\6\nlocal RULE_PORT_DEST=\7/'

	# output is like:
	# local RULE_NAME=webcam
	# local RULE_ACTIVE=on
	# local RULE_INCOMING_INTERFACE=all	// wan,lan,wifi,all/any
	# local RULE_PROTO=tcp
	# local RULE_PORT_INCOMING=8080
	# local RULE_DEST_IP=10.63.168.97	// ip4 or 'me' = myself
	# local RULE_PORT_DEST=80
}

_pfilter_stats_user_traffic_list_today()
{
	local media mac
	local traffic=0
	local list_macs="$( _pfilter user_list )"

	for mac in $list_macs ; do {
	
		traffic="$( _pfilter stats_user_traffic "$mac" today )"
	
		[ "$traffic" = "0" ] || {
			traffic="$( _math bytes2unit "$traffic" mb )"
			media="$( _net mac2media "$mac" short )"
			mac="$( echo "$mac" | sed 's/://g' )"

			echo -en "${media}${mac}:${traffic}"
		}
	} done
}

_pfilter_rules_nat_wifi_roaming ()
{
	local FUNC="pfilter_rules_nat_wifi_roaming"
	
	_log do $FUNC daemon info "masquerading outgoing wifi '$WIFIDEV'"

	eval "$( _ipsystem do | grep ^ROAMING_ )"

	_ipt -t nat -A POSTROUTING -o $WIFIDEV -s $ROAMING_IP4/$ROAMING_PRE -j MASQUERADE	# or SNAT?
}

_pfilter_user_probe_local_blacklist ()
{
	local MAC="$1"

	uci get system.@ethers[0].blocked | grep -q -i $MAC && return 0
	return 1
}

_pfilter_rules_nat_inetoffer_lan ()		# SENS: masquerades traffic over lan-device for omitting "black hole"
{						#       and fetches IP from local DHCP-server, if gateway-IP is not from local IP-range
	local FUNC="pfilter_rules_nat_inetoffer_lan"
	_log do pfilter daemon info "($FUNC) working"

	local GATEWAY="$( uci get network.lan.gateway )"
	local COUNTER=0
	local ALIASIP										# is lan_gateway an alien network?
												# then add alien-ip-range to alias-interface...

	if [ -n "$GATEWAY" ] && [ -z "$( ip route list exact 0.0.0.0/0 via $GATEWAY )" ]; then	# def_route could'nt be set by /sbin/ifup
												# because kernel has no suiteable interface for gw
		while [ $COUNTER -lt 5 ]; do {
			_log do $FUNC daemon info "detected alien LAN-gateway, trying to fetch DHCP-address"

			# fixme! newer udhcpc sets the IP, even on virtual interfaces, so we have to find a way to:
			# - get a lease
			# - discard/ignore the lease
			# - reinit the interface to old state (if changed)

			ALIASIP="$( udhcpc -qfn --interface="$LANDEV:fantasy" 2>/dev/null | sed -n 's/.* \([0-9]*\.[0-9]*\.[0-9]*\.[0-9]*\) .*/\1/p' )"
			[ -n "$ALIASIP" ] && break

			_log do pfilter daemon info "($FUNC) no alias-ip - trying again in 10 sec"
			sleep 10
			COUNTER=$(( $COUNTER + 1 ))		# fixme! even with "LAN:fantasy" /etc/resolv.conf gets applied, rewrite?
		} done
		
		[ -z "$ALIASIP" ] && {
			
			# last octett is now hard set to 234, so when
			# gateway is 192.168.178.1   , we set
			#            192.168.178.234 on our LAN-address		# fixme! uiuiui! what when lan_gateway is not reachable anymore?
			
			ALIASIP="$( echo $GATEWAY | sed -n 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)\..*/\1.\2.\3.234/p' )"
			
			_log do pfilter daemon info "($FUNC) couldt fetch IP-address from LAN-DHCP-server, guessing"
		}
		
		_log do pfilter daemon info "($FUNC) using alienip '$ALIASIP' to reach gateway"
		
		local ALIASPRE="$( ipcalc -p $ALIASIP           | sed -n 's/PREFIX=\(.*\)/\1/p' )"
		local ALIASNET="$( ipcalc -n $ALIASIP/$ALIASPRE | sed -n 's/NETWORK=\(.*\)/\1/p' )"
		local LANNET="$ALIASNET"
		local LANPRE="$ALIASPRE"

		_log do pfilter daemon info "($FUNC) local alien-address gateway"
		_log do pfilter daemon info "($FUNC) adding $ALIASIP/$ALIASPRE on $LANDEV:aliennet"
		_log do pfilter daemon info "($FUNC) adding default route"
		
		ip address add $ALIASIP/$ALIASPRE   dev $LANDEV label $LANDEV:aliennet
		ip route   add default via $GATEWAY dev               $LANDEV metric 0

		# fixme! apply now static_routes, which could be used till now?
	
		if [ "$?" -ne 0 ]; then
			_log do pfilter daemon info "($FUNC) error adding default route"
		else
			_log do pfilter daemon info "($FUNC) success adding default route"	# fixme! why we restart vpn?
			/etc/init.d/S*vpn* restart				# uiuiui! better use an central
										# function to automatically ifup/down
										# vpn-connection (cron.minutely hna4-hook?)
		fi
	fi	
	
	_ipt -A POSTROUTING -t nat -o $LANDEV ! -s $LANNET/$LANPRE -j MASQUERADE
	_ipt -A POSTROUTING -t nat -o $WIFIDEV -s   $LANNET/$LANPRE -j MASQUERADE

	_pfilter stats_rules_count nat POSTROUTING
	_log do pfilter daemon info "($FUNC) done"
}

_pfilter_user_traffic_limit ()
{
	local MAC="$1"
	local DEFAULT_MEGABYTES="9999"		# fixme! ask _db user -> profile()

	[ -z "$MAC" ] && {
		echo 0
		return
	}

	local OUT=0								# traffic variables are known from /etc/variables_fff+
	local WIFI_MODE="$( _wifi mode $WIFIDEV )"
	local MEDIA="$( _net mac2media $MAC )"

	_pfilter user_list_local_registered | grep -q -i $MAC
										# now we make differences for anonym or locally registered
										# and wire / wireless / wireless_in_non-mesh-disturbing ap-mode (other channel!)
										
	if [ "$?" -eq 0 ]; then							# locally registered

		if [ "$MEDIA" = "wire" ] || [ "$WIFI_MODE" = "ap" ] ; then	# locally registered, wire or AP
			OUT="$( uci get system.@community[0].maxtraffic | cut -d':' -f4 )"
		else								# locally registered, wifi
			OUT="$( uci get system.@community[0].maxtraffic | cut -d':' -f3 )"
		fi
	else
		if [ "$MEDIA" = "wire" ] || [ "$WIFI_MODE" = "ap" ]; then	# anonym, wire or AP
			OUT="$( uci get system.@community[0].maxtraffic | cut -d':' -f2 )"
		else								# anonym, wifi
			OUT="$( uci get system.@community[0].maxtraffic | cut -d':' -f1 )"
		fi
	fi

	echo "${OUT:-$DEFAULT_MEGABYTES}000000"					# convert MBytes in Bytes 8-)
}

_pfilter_stats_user_traffic_used_percent ()		# ARG1: mac-address
{									# OUT1: integer - can be higher then 100% (!)
	local MAC="$1"
	local STEP1
	local STEP2
	local STEP3
	
	_pfilter user_list | grep -q -i $MAC || {
		echo "0"
		return
	}

	STEP1="$( _pfilter stats_user_traffic $MAC today )"					# hint: traffic_today * 100 / traffic_limit
	STEP2="$( _pfilter user_traffic_limit $MAC )"	#       is the same like:
	STEP3="$( _math divide100 $STEP2 )"						#       traffic_today / (traffic_limit/100)

	echo $(( $STEP1 / $STEP3 ))							#       doing it this way we avoid big numbers during bash-calculation
}

_pfilter_user_splash_remove_autounsplashed ()
{
	local FUNC="pfilter_user_splash_remove_autounsplashed"
	local ENTRY MAC IP
	local LIST="$( grep "^..:..:..:..:..:.. free-" /etc/ethers ; grep "^..:..:..:..:..:.. admin-" /etc/ethers)"

	_log do $FUNC daemon info "checking"

	for ENTRY in $LIST; do {					# MAC NAME MAC NAME ...

		if   _sanitizer do "$ENTRY" mac check ; then
			MAC=$ENTRY					# remember for next loop-cycle
		else
			IP="$( fgrep "$ENTRY" /etc/local.hosts | cut -d" " -f1 )"	# is a hack!

			_log do $FUNC daemon info "adding name/mac/ip '$NAME' / '$IP' / '$MAC'"

			_pfilter user_add $MAC $IP
		fi
	} done
}

_pfilter_user_splash_add_for_nonautounsplashed ()
{
	local FUNC="pfilter_user_splash_add_for_nonautounsplashed"

	local LIST="$( _pfilter user_list )"
	local TABLE LINE IP MAC

	rm /tmp/login_was_sent_to_mobilenumber_* 2>/dev/null		# fixme!

	_net local_inet_offer >/dev/null || {
		_pfilter rules_remove_all_masquerading
	}

	for MAC in $LIST; do {
		
		_pfilter user_probe_splash $MAC || {
			
			_pfilter user_probe_autounsplashed $MAC || {
				_log do $FUNC daemon debug "kicking '$MAC'"
				_pfilter user_splash_control splash "$MAC" "$( _net mac2ip $MAC )"
			}
		}
	} done

	first_line_is_walled_garden ()		# fixme! under rare circumstances, above loop does not catch all users
	{
		iptables -t mangle -nL PREROUTING | fgrep -q walled_garden || {
			_log do $FUNC daemon alert "[ERR] walled_garden seems inactive, abort"
			return 0		# workaround for bad table
		}

		iptables -t mangle -nL PREROUTING --line-number | grep -q ^"1    walled_garden"
	}

	while ! first_line_is_walled_garden; do {
		_log do $FUNC daemon info "removing first trashline: $( iptables -t mangle -nL PREROUTING --line-number | grep ^"1 " )"
		iptables -t mangle -D PREROUTING 1
	} done

	listof_linenumbers_from_references_in_user_tables()
	{
		iptables --line-numbers -t mangle -nxvL traff_users |
		 fgrep -v "_99:99:99:99:99:9" |
		  grep "traff_[0-9a-fA-F][0-9a-fA-F]:" |
		   cut  -d' ' -f1 |
		    sort -r
	}

	listof_trashtables_in_inputmangle()
	{
		iptables -t mangle -nL |
		 grep ^"Chain traff_[0-9a-fA-F][0-9a-fA-F]:" |
		  fgrep -v "_99:99:99:99:99:9" |
		   cut -d' ' -f2
	}

	for TABLE in $( listof_trashtables_in_inputmangle ); do {
		_log do $FUNC daemon info "removing $TABLE"
		_ipt -t mangle -F $TABLE

		for LINE in $( listof_linenumbers_from_references_in_user_tables ); do {
			_ipt -t mangle -D traff_users $LINE
		} done

		_ipt -t mangle -X $TABLE
	} done

	list_of_ip_known_lan_arpneighs()
	{
		grep $LANDEV$ /proc/net/arp | cut -d' ' -f1

		local mac ip
		for mac in $LIST; do {				# fixme! use local var

			ip="$( _net mac2ip $mac )"

			case "$( _net ip2dev "$ip" )" in
				$LANDEV)
					echo "$ip"
				;;
			esac
		} done
	}

	list_of_ip_to_autoactivate()
	{
		local ip_list="$( list_of_ip_known_lan_arpneighs | sort | uniq )"
		local ip
		local profile="$( uci get system.@profile[0].name )"

		for ip in $ip_list; do {
			case "$profile" in
				vivaldi*)
					case "$ip" in
						192.168.1.34|192.168.1.35|192.168.1.36|192.168.1.37|192.168.1.38|192.168.1.39|192.168.1.40|192.168.1.41|192.168.1.42|192.168.1.43|192.168.1.44|192.168.1.45|192.168.1.46)
							:
						;;
						*)
							echo "$ip"
						;;
					esac
				;;
				*)
					echo "$ip"
				;;
			esac
		} done
	}

	for IP in $( list_of_ip_to_autoactivate ); do {

		_olsr ip_is_neigh $IP || {

			MAC="$( _net ip2mac $IP )"
			_log do $FUNC daemon info "autoactivating lan-neigh with mac/ip: $MAC/$IP"

			/etc/local.fw-fff+ adduser "$MAC" "$IP"
		}
	} done

	ip neigh flush all		# remove permanent arp-entries
}

_pfilter_user_kick_overlimit ()
{
	local FUNC="pfilter_user_kick_overlimit"
	local LIST="$( _pfilter user_list )"
	local LIMIT
	local PERCENT
	local MAC

	for MAC in $LIST; do {

		[ "$( _pfilter stats_user_traffic $MAC today )" != "0" ] && {	# very fast check
		
			_pfilter user_probe_splash $MAC || {
		
				_pfilter user_probe_admin $MAC || {
		
					PERCENT="$( _pfilter stats_user_traffic_used_percent $MAC )"
					_log do $FUNC user debug "'$MAC'-traffic is ${PERCENT}%"
				
					[ $PERCENT -gt 100 ] && {
						LIMIT="$( _pfilter user_traffic_limit $MAC )"
						LIMIT="$( _sanitizer do "$LIMIT" number_humanreadable )"
						_log do $FUNC user info " -'$MAC' (traffic: ${PERCENT}% ~${LIMIT} bytes)"
						_pfilter user_splash_control splash "$MAC" "$( _net mac2ip $MAC )"
					}
				}
			}
		}
	} done
}

_pfilter_user_traffic_reset ()
{
	local FUNC="pfilter_user_traffic_reset"
	local LIST="$( _pfilter user_list )"
	local MAC
	
	for MAC in $LIST; do {
		_pfilter user_traffic_reset_single $MAC today	
	} done
}

_pfilter_stats_olsr_traffic_wifi_in ()
{
	local PACK BYTES REST
	
	iptables -nxvL olsr_in 2>/dev/null | head -n3 | tail -n1 | while read PACK BYTES REST; do echo -n ${BYTES:-0}; done
}

_pfilter_stats_olsr_traffic_wifi_out ()
{
	local PACK BYTES REST
	
	iptables -nxvL olsr_out_wifi 2>/dev/null | tail -n1 | while read PACK BYTES REST; do echo ${BYTES:-0}; done
}

_pfilter_stats_layer7_hits ()
{
	local PACK BYTES REST
	
	local ALL_BYTES="$(      iptables -t mangle -nxvL FORWARD | grep "CONNMARK restore" | while read PACK BYTES REST; do echo $BYTES; done )"
	local RESTORED_BYTES="$( iptables -t mangle -nxvL FORWARD | grep "CONNMARK match"   | while read PACK BYTES REST; do echo $BYTES; done )"
	local MATCHED_BYTES="$(  iptables -t mangle -nxvL marking | grep "CONNMARK"         | while read PACK BYTES REST; do echo $BYTES; done )"

	which awk >/dev/null || {
		echo 0
		return
	}
	awk -v A=$ALL_BYTES -v R=$RESTORED_BYTES -v M=$MATCHED_BYTES 'BEGIN{ printf("%.2f",(R+M)*100/A) }'

	# local STEP1="$(( $RESTORED_BYTES + $MATCHED_BYTES ))"
	# local STEP2="$(( $ALL_BYTES / 1000 ))"
	# _math divide10 "$(( $STEP1 / $STEP2 ))"
}

_pfilter_stats_user_cast ()
{
	local KEYWORD="$1"			# ARG1: 'spread' = data goes out to $GATEWAY and $NEXTHOP
	local LIST="$( _pfilter user_list )"
	local URL MSG DATE TIME TRAFF_RECENT TRAFF_TODAY TRAFF_ALL MEDIA NAME NODE REG OUTPUT MAC
	local DATE HOSTNAME COST_INT GATEWAY NEXTHOP METRIC

	. /tmp/GATEWAY_CHECK_RECENT	# need: NEXTHOP|GATEWAY is: DATE|HOSTNAME|COST_INT|GATEWAY|NEXTHOP|METRIC

	for MAC in $LIST; do {

		DATE="$( _system date humanreadable )"
		TIME="$( _system date unixtime	    )"
			
		TRAFF_RECENT="$( _pfilter stats_user_traffic $MAC recent )"

		[ $TRAFF_RECENT -ne 0 ] && {
			_pfilter user_traffic_reset_single $MAC recent
		}

		TRAFF_TODAY="$(  _pfilter stats_user_traffic $MAC today  )"
		TRAFF_ALL="$(    _pfilter stats_user_traffic $MAC all    )"
			
		MEDIA="$( _net mac2media    $MAC )"
		NAME="$(  _net mac2hostname $MAC )"
		NODE="local"
		REG=0
	
		OUTPUT="NODE=$NODE TIME=$TIME DATE=$DATE MAC=$MAC NAME=$NAME REG=$REG MEDIA=$MEDIA TRAFF_RECENT=$TRAFF_RECENT TRAFF_TODAY=$TRAFF_TODAY TRAFF_ALL=$TRAFF_ALL"

		MAC="$( _sanitizer do "$MAC" mac lowercase urlvalue )"

		[ "$KEYWORD" = "spread" -a $TRAFF_RECENT -gt 0 ] && {

			echo $OUTPUT				# fixme! better _log()?
			echo $OUTPUT >>/tmp/ARCHIV_TRAFFIC

			URL="http://$GATEWAY/cgi-bin-traffic_fff+?"
			MSG="MAC=${MAC}&NAME=${NAME}&REG=${REG}&MEDIA=${MEDIA}&TRAFF_RECENT=${TRAFF_RECENT}&TRAFF_TODAY=${TRAFF_TODAY}&TRAFF_ALL=${TRAFF_ALL}"

			_wget do "${URL}${MSG}" 5 >/dev/null
			
			[ "$GATEWAY" != "$NEXTHOP" ] && {
				URL="http://$NEXTHOP/cgi-bin-traffic_fff+?"				
				_wget do "${URL}${MSG}" 5 >/dev/null
			}
		}
	} done
}

_pfilter_user_probe ()
{
	local MAC="${1:-unset}"
	
	iptables -t mangle -nL traff_${MAC} >/dev/null 2>/dev/null && return 0		# not using _ipt()
	return 1
}

_pfilter_user_list ()					# SENS: list all MACs from logged in / shaped users
{
	iptables -t mangle -nL traff_users 2>/dev/null |
	 sed -n 's/^traff_\([0-8abcdef][0-8abcdef]:..:..:..:..:..\) .*MAC .*$/\1/p'	# must not begin with '99' (=reserved user)
}

_pfilter_user_list_blocked ()
{
	IFS=";"
	for MAC in $( uci get system.@ethers[0].blocked ); do {
		echo "$MAC"
	} done
	unset IFS
}

_pfilter_user_list_dhcp_active ()
{
	local leasefile="$( _net dhcp_lease_filename )"

	sed -n 's/^.* \(..:..:..:..:..:..\) .*/\1/p' $leasefile		# must be lowercase
}

_pfilter_user_list_local_registered ()
{
	local MAC
	
	IFS=";"
	for MAC in $( uci get system.@ethers[0].wifi ) $( uci get system.@ethers[0].lan ); do {
		echo "${MAC%=*}"				# print word before "="
	} done
	unset IFS
}

_pfilter_user_traffic_reset_single ()
{
	local FUNC="pfilter_user_traffic_reset_single"
	local MAC="$1"
	local RULE_NUM="$2"
	local LOGPRIO="info"
	
	case $RULE_NUM in
		recent) RULE_NUM=2
			LOGPRIO="debug"		# last 15min
		;;
		 today) RULE_NUM=3		# today
		;;
		     *) RULE_NUM=4		# overall
		;;
	esac

	_log do $FUNC daemon $LOGPRIO "$MAC ('$2')"
	
	_ipt -R traff_$MAC $RULE_NUM -t mangle --set-counters 0 0
}

_pfilter_stats_traffic_forwarded_intranet ()
{
	local PACK BYTES REST
	
	iptables -nxvL FORWARD 2>/dev/null | head -n3 | tail -n1 | while read PACK BYTES REST; do echo $BYTES; done
}

_pfilter_stats_traffic_forwarded_internet ()	# fixme! empty chains -> output = "bytes", but should be '0'
{
	local PACK BYTES REST
	
	iptables -t mangle -nxvL FORWARD 2>/dev/null | head -n3 | tail -n1 | while read PACK BYTES REST; do echo $BYTES; done
}

_pfilter_stats_user_conns_start ()	# we don't use _ipt() abstraction because chains maybe does not exist / avoid syslog errors
{
	local MAC="$1"
	
	iptables -t mangle -nxvL traff_$MAC | fgrep "state NEW MARK set 0x91" | sed -n 's/^[^0-9]*\([0-9]*\)[^0-9]*.*/\1/p'
}

_pfilter_stats_user_conns_end ()
{
	local MAC="$1"

	iptables -t mangle -nxvL traff_$MAC | fgrep "flags:0x11/0x11 MARK" | tail -n1 | sed -n 's/^[^0-9]*\([0-9]*\)[^0-9]*.*/\1/p'
}

_pfilter_stats_user_conns_over_limit ()		# we count udp + tcp above's 	// fixme! what about adblock?
{
	local MAC="$1"
	local PACK=""
	local REST=""	

	iptables -t mangle -nxvL traff_$MAC | head -n 9 | tail -n 1 | while read PACK REST; do echo $PACK; done
}

_pfilter_stats_user_traffic ()	# OUT1: string
{
	local MAC="$1"
	local TIMESLOT="$2"
	local LINE
	
	case $TIMESLOT in
		recent) LINE="2" ;;	# last 15min
		today)  LINE="3" ;;	# today
		*)      LINE="4" ;;	# overall
	esac

	iptables -t mangle --line-numbers -nxvL traff_${MAC} | 
	 sed -n "/^${LINE} /s/^${LINE}[^0-9]*[0-9]*[^0-9]*\([0-9]*\).*/\1/p"
}

_pfilter_proto2id ()
{
	local wish_proto="$1"
	local wish_port="$2"
	local entry proto port success
	local id=0

	case "$wish_proto" in

		PING) id=98 ;;
		TRACE) id=97 ;;
		NTP) id=96 ;;
		FRAG) id=95 ;;
		TTL0) id=94 ;;
		UNREA) id=93 ;;
		CONN_ABOVE) id=92 ;;
		CONN) id=91 ;;
		GARDEN) id=90 ;;
		REDIRECT) id=89 ;;
		REJECT) id=88 ;;
		DHCPIN) id=87 ;;
		PICOPEER) id=86 ;;
		GUESS) id=85 ;;
		SMALL) id=84 ;;

		*)
			case "$wish_proto" in				# ssh,22
				*,*)
					wish_port="${wish_proto#*,}"	# 22
					wish_proto="${wish_proto%,*}"	# ssh
				;;
			esac

			for entry in $( _pfilter l7proto_list ); do {		# fixme! optimize: runs often

				proto="${entry%,*}"
				port="${entry#*,}"

				[ -z "$wish_port" ] && port=

				id=$(( $id + 1 ))

				[ "$wish_proto" = "$proto" -a "$wish_port" = "$port" ] && {
					success="true"
					break
				}
			} done

			[ -z "$success" ] && {
				id=99
			}
		;;
	esac

	echo "0x${id}"
}

_pfilter_user_probe_admin ()
{
	local MAC="$1"
	local LIST="$( uci get system.@ethers[0].lan ) $( uci get system.@ethers[0].wifi )"

	echo "$LIST" | grep -qi "${MAC}=admin-"
}

_pfilter_user_probe_autounsplashed ()		# free means no splashpage wished: username must begin with "admin-" or "free-"
{
	local MAC="$1"
	local LIST="$( uci get system.@ethers[0].lan ) $( uci get system.@ethers[0].wifi )"
	
	echo $LIST | grep -qi "${MAC}=free-"  && return 0
	echo $LIST | grep -qi "${MAC}=admin-" && return 0
	return 1
}

_pfilter_user_probe_splash ()
{
	local MAC="${1:-unset}"			# not using _ipt()

	iptables -t mangle -nL PREROUTING | grep -qi $MAC && return 1	# mac is accepted in prerouting/mangle: no redirection is made
	return 0							# mac is not known in prerouting/mangle: user gets splash page
}

_pfilter_user_splash_control ()				# SENS: controlling if a user must see splashpage before using internet or not
{							# ARG1: nosplash,splash
							# ARG2: mac
	local FUNC="pfilter_user_splash_control"	# ARG3: ip-address
	local MODE="$1"
	local MAC="$2"
	local IP="$3"
	local tunnel_mode

	_log do $FUNC daemon info "[OK] start - mode: $MODE - $MAC / $IP"

	[ -z "$MODE" -o -z "$MAC" -o -z "$IP" ] && {
		_log do $FUNC daemon alert "[ERR] no mode '$MODE' nor mac '$MAC' nor ip '$IP' given, aborting"
		return
	}

	case "$MAC" in
		00:00:00:00:00:00)		# fixme! see dhcp-script
			return
		;;
	esac

	if [ "$MODE" = "nosplash" ]; then
		MODE="-I"

		iptables -t mangle -nL PREROUTING | grep -i -q "$MAC" && {
			_log do $FUNC daemon info "[OK] already unsplashed, ignoring call"
			return
		}

		echo "$IP"  >/tmp/MAC2IP_${MAC}		# fixme! is a hack for _net_mac2ip
		echo "$MAC" >/tmp/IP2MAC_${IP}

		tunnel_mode="start"
	else
		MODE="-D"

		_net dhcp_lease_remove "$MAC"

		tunnel_mode="stop"
	fi

	_ipt -t mangle $MODE PREROUTING -m mac --mac-source $MAC -j ACCEPT
	_ipt -t mangle $MODE PREROUTING -d $IP                   -j ACCEPT	

	_tunnel clientside_control "$tunnel_mode" "$MAC" "$IP"

	_log do $FUNC daemon info "[OK] end - mode: $MODE - $MAC / $IP"
}

_pfilter_user_add ()		# SENS: generate MAC-specific shaping/accounting-chain
{
	local FUNC="pfilter_user_add"
	local MAC="$1"
	local  IP="$2"
	local ARP="$3"		# fixme! sens of $3 ?
	local KEYWORD="$4"
	local MYHNA="$( uci get olsrd.@Hna4[0].netaddr )/$( _net mask2cidr $( uci get olsrd.@Hna4[0].netmask ) )"

	[ "$KEYWORD" != "reserve" ] && {
		_log do $FUNC daemon debug "instant call - trying to activate reserved user chain"

		_pfilter user_ruleset_activate $MAC $IP && {
			_log do $FUNC daemon debug "successfully activated reserved user chain"
			return 0
		}
	}

	[ -z "$IP" ] && {
		_log do $FUNC daemon info "no MAC or no IP given - aborting"
		return 1
	}
					# normal users
	local CONN_LIMIT_UDP="20"	# was 5
	local CONN_LIMIT_TCP="75"	# was 20

	_net local_inet_offer >/dev/null && {
	
		_log do $FUNC daemon info "raising connection-count for this user"

		CONN_LIMIT_UDP="50"		# free-users on node with inet-offer
		CONN_LIMIT_TCP="100"
	
		_pfilter user_probe_admin $MAC && {

			_log do $FUNC daemon info "boosting connection-count for this admin-user"

			CONN_LIMIT_UDP="1000"
			CONN_LIMIT_TCP="4096"
		}
	}
	
	_log do $FUNC daemon debug "$MAC / $IP (connlimit tcp/udp: $CONN_LIMIT_TCP/$CONN_LIMIT_UDP)"

	[ -z "$ARP" ] && _net arp_permanent $IP $MAC

	_log do $FUNC daemon info "[START] filling user chain"

	_ipt -t mangle -N traff_$MAC 2>/dev/null || {
		_log do $FUNC daemon info "chain traff_$MAC already exists - abort"

		[ $( _ipt -t mangle -N traff_$MAC 2>/dev/null | wc -l ) -gt 2 ] && {
			_log do $FUNC daemon info "chain traff_$MAC already exists and is not empty - abort"
			return 1
		}
	}

	_ipt -t mangle -A traff_$MAC -s $WIFINET/$WIFIPRE -d $WIFINET/$WIFIPRE -j shaper	# counter0 (intranet/mesh-intern)
	_ipt -t mangle -A traff_$MAC								# counter1 (traffic interval-count)
	_ipt -t mangle -A traff_$MAC								# counter2 (traffic_today)
	_ipt -t mangle -A traff_$MAC								# counter3 (traffic_all)

	_ipt -t mangle -A traff_$MAC -s $MYHNA -m state --state NEW -d 1.1.0.0/20 -m limit --limit 6/min --limit-burst 10 -j LOG --log-prefix "ADBLOCK: "
	_ipt -t mangle -A traff_$MAC -s $MYHNA -m state --state NEW -d 1.1.0.0/20        -j MARK --set-mark $( _pfilter proto2id REJECT )    # adblock (special dest)
	_ipt -t mangle -A traff_$MAC -m mark --mark $( _pfilter proto2id REJECT )/0xFF  -j shaper

	_ipt -t mangle -A traff_$MAC -m state --state NEW -p udp
	_ipt -t mangle -A traff_$MAC -m state --state NEW -p tcp

	_ipt -t mangle -A traff_$MAC -m mark --mark $( _pfilter proto2id CONN_ABOVE )/0xFF                           -j shaper	# connabove to shaper

	_ipt -t mangle -A traff_$MAC -s $MYHNA -m state --state NEW                   -j MARK --set-mark $( _pfilter proto2id CONN )	# all new packets

	_ipt -t mangle -A traff_$MAC -m mark --mark $( _pfilter proto2id CONN )/0xFF       -j ULOG --ulog-prefix "$MAC>"       # inside2outside
	_ipt -t mangle -A traff_$MAC -m mark --mark $( _pfilter proto2id CONN )/0xFF       -j shaper

	_ipt -t mangle -A traff_$MAC -s $MYHNA -p tcp --tcp-flags fin,ack fin,ack     -j MARK --set-mark $( _pfilter proto2id CONN )    # FIN&ACK is set
	_ipt -t mangle -A traff_$MAC -s $MYHNA -p tcp --tcp-flags rst rst             -j MARK --set-mark $( _pfilter proto2id CONN )    # RST     is set

	_ipt -t mangle -A traff_$MAC -d $MYHNA -p tcp --tcp-flags syn,ack syn,ack     -j MARK --set-mark $( _pfilter proto2id CONN )	# better? SYN&ACK in answer is set
	_ipt -t mangle -A traff_$MAC -d $MYHNA -p tcp --tcp-flags fin,ack fin,ack     -j MARK --set-mark $( _pfilter proto2id CONN )	# better? FIN&ACK in answer is set
	_ipt -t mangle -A traff_$MAC -d $MYHNA -p tcp --tcp-flags rst rst             -j MARK --set-mark $( _pfilter proto2id CONN )	# better? RST     in answer is set

	_ipt -t mangle -A traff_$MAC -m mark --mark $( _pfilter proto2id CONN )/0xFF    -j ULOG --ulog-prefix "${MAC}<"	# outside2inside
	_ipt -t mangle -A traff_$MAC -m mark --mark $( _pfilter proto2id CONN )/0xFF    -j shaper 

	_ipt -t mangle -A traff_$MAC -m connbytes --connbytes   97999:99999   --connbytes-dir both --connbytes-mode bytes
	_ipt -t mangle -A traff_$MAC -m connbytes --connbytes  997999:999999  --connbytes-dir both --connbytes-mode bytes
	_ipt -t mangle -A traff_$MAC -m connbytes --connbytes 9997999:9999999 --connbytes-dir both --connbytes-mode bytes

	iptables -t mangle -nL traff_users | grep -q ^traff_$MAC || {
		_ipt -t mangle -A traff_users -m mac --mac-source $MAC	-j traff_$MAC
		_ipt -t mangle -A traff_users -d $IP			-j traff_$MAC
	}

	for ENTRY in $( _pfilter l7proto_list ); do {
		_ipt -t mangle -A traff_$MAC -m mark --mark $( _pfilter proto2id $ENTRY )/0xFF	-j shaper
		_ipt -t mangle -A traff_$MAC -m mark --mark $( _pfilter proto2id $ENTRY )/0xFF	-j LOG --log-prefix "l7_${ENTRY}: "
		_ipt -t mangle -A traff_$MAC -m mark --mark $( _pfilter proto2id $ENTRY )/0xFF	-j RETURN
	} done

	_ipt -t mangle -A traff_$MAC -m mark --mark $( _pfilter proto2id UNKN )/0xFF		-j shaper				# unknown traffic
	_ipt -t mangle -A traff_$MAC -m mark --mark $( _pfilter proto2id UNKN )/0xFF		-j LOG --log-prefix "l7_UNKNOWN: "
	_ipt -t mangle -A traff_$MAC -m mark --mark $( _pfilter proto2id UNKN )/0xFF		-j RETURN

	_pfilter user_splash_control nosplash "$MAC" "$IP"

	_log do $FUNC daemon info "[START] filling user chain"
}

_pfilter_rules_install ()			# fixme! connbytes auswerten: http ab 200k = langsame klasse/download?
{
	local FUNC="pfilter_rules_install"

	_pfilter kmodules_init			# connection-aufbau /pro user /pro zeiteinheit limitieren
						# connections /pro user limitieren
						# icmp /ping pro user /pro zeiteinheitlimitieren
						# unabhaengig von einteilung bestimmte packet trotzdem in prio veraendern (ACK...)

	local MYHNA="$( uci get olsrd.@Hna4[0].netaddr )/$( _net mask2cidr $( uci get olsrd.@Hna4[0].netmask ) )"
	
	_log do $FUNC daemon info "start"

	_ipt -t mangle -N marking
	_ipt -t mangle -N marking_unmarkable
	_ipt -t mangle -N marking_layer7
	_ipt -t mangle -N traff_all
	_ipt -t mangle -N traff_users
	_ipt -t mangle -N shaper

	_ipt -A FORWARD -m mark --mark $( _pfilter proto2id REJECT )		-j REJECT
	_ipt -A FORWARD -m mark --mark $( _pfilter proto2id CONN_ABOVE )/0xFF	-j REJECT  	# --reject-with tcp-reset (does not work?)
	_ipt -A FORWARD -s $WIFINET/$WIFIPRE -d $WIFINET/$WIFIPRE		-j ACCEPT

		# http://www.frozentux.net/iptables-tutorial/iptables-tutorial.html#TABLE.TCPMSSTARGET
		# MSS (maximum segment size) should always be path_MTU - 40 (20 for IP header + 20 for TCP header)
		# fixme! restrict to '-o $LAN/$WIFI/$WAN' ?

	_ipt -A FORWARD -p tcp --tcp-flags SYN,RST SYN				-j TCPMSS --clamp-mss-to-pmtu
	_ipt -A FORWARD -m state --state ESTABLISHED,RELATED			-j ACCEPT

	# maybe let already marked traffic go trough?

	_pfilter stats_p2p_block && {
		_ipt -A FORWARD -m ipp2p --ipp2p                                 -j LOG --log-prefix "ip_p2p: "
		_ipt -A FORWARD -m ipp2p --ipp2p                                 -j DROP
	}

	_ipt -A FORWARD -m state --state NEW                             -j ACCEPT

	_ipt -t mangle -A FORWARD ! -s $MYHNA ! -d $MYHNA  -j ACCEPT				# forwarding (but not my own forwarding)
	_ipt -t mangle -A FORWARD -m mark ! --mark 0       -j ACCEPT				# already marked in e.g. PREROUTING
	_ipt -t mangle -A FORWARD                          -j CONNMARK --restore-mark		# trying to get mark from maybe already known connection
	_ipt -t mangle -A FORWARD -m connmark ! --mark 0x0 -j traff_all				# connection known/marked? then goto traff_all
	_ipt -t mangle -A FORWARD                          -j marking				# connection not known! try to mark

	_ipt -t mangle -A traff_all
	_ipt -t mangle -A shaper    -j ACCEPT

	_ipt -t mangle -A marking_unmarkable -p tcp  -m length --length 85:1500					-j RETURN
	_ipt -t mangle -A marking_unmarkable -p tcp  -m length --length 0:40 --tcp-flags RST,URG     RST	-j MARK --set-mark $( _pfilter proto2id SMALL )
	_ipt -t mangle -A marking_unmarkable -p tcp  -m length --length 0:52 --tcp-flags ACK,URG     ACK	-j MARK --set-mark $( _pfilter proto2id SMALL )
	_ipt -t mangle -A marking_unmarkable -p tcp  -m length --length 0:64 --tcp-flags SYN,URG     SYN	-j MARK --set-mark $( _pfilter proto2id SMALL )
	_ipt -t mangle -A marking_unmarkable -p tcp  -m length --length 0:64 --tcp-flags ACK,SYN,URG ACK,SYN	-j MARK --set-mark $( _pfilter proto2id SMALL )
	_ipt -t mangle -A marking_unmarkable -p icmp -m length --length 84					-j MARK --set-mark $( _pfilter proto2id SMALL )	# ping
#	_ipt -t mangle -A marking_unmarkable -m mark ! --mark 0							-j LOG --log-prefix "l7_small: "
#	_ipt -t mangle -A marking_unmarkable -m mark ! --mark 0							-j RETURN

	if _pfilter stats_simple_approach ; then
		_ipt -t mangle -A marking_layer7 -j MARK --set-mark $( _pfilter proto2id http 80 )
		_ipt -t mangle -A marking_layer7 -j RETURN
	else
		for ENTRY in $( _pfilter l7proto_list ); do {

			_log do $FUNC daemon info "loop_layer7: installing protocol '$ENTRY'"

			_ipt -t mangle -A marking_layer7 -m layer7 --l7proto $PROTO		-j MARK --set-mark $( _pfilter proto2id $ENTRY )
		#	_ipt -t mangle -A marking_layer7 -m mark ! --mark 0			-j LOG --log-prefix "l7_${ENTRY}: "
			_ipt -t mangle -A marking_layer7 -m mark ! --mark 0			-j RETURN
			_ipt -t mangle -A traff_all      -m mark --mark $( _pfilter proto2id $ENTRY )/0xFF	-j traff_users
		} done
	fi

	_ipt -t mangle -A marking_layer7 -j LOG --log-prefix "l7_end: "
	
	_ipt -t mangle -A traff_all -m mark --mark $( _pfilter proto2id UNKN )/0xFF -j traff_users	# list unknown traffic
	_ipt -t mangle -A traff_all                                            -j traff_users
	_ipt -t mangle -A traff_all                                            -j shaper
	
	_ipt -t mangle -A marking -m mark ! --mark 0			-j traff_all					# already marked in prerouting?
	_ipt -t mangle -A marking					-j marking_unmarkable				# fixme!
#	_ipt -t mangle -A marking -m mark --mark $( _pfilter proto2id SMALL )	-j MARK --set-mark 0
	_ipt -t mangle -A marking -m mark ! --mark 0			-j marking_layer7				# trying all layer7-filters
	_ipt -t mangle -A marking -m mark ! --mark 0			-j CONNMARK --save-mark				# layer7-matching was successful!
	_ipt -t mangle -A marking -m mark ! --mark 0			-j traff_all					# goto traff_all
	_ipt -t mangle -A marking					-j MARK --set-mark $( _pfilter proto2id UNKN )	# mark unknown traffic
	_ipt -t mangle -A marking					-j traff_all

	_log do $FUNC daemon info "end"
}

_pfilter_kmodules_init ()	# fixme! alles durch _ipt () schleifen und erst bei bedarf laden
{
	local MODULE
#	local LIST_MATCH="conntrack connbytes connlimit connmark udplimit length layer7 ipp2p ttl"
	local LIST_CONNTRACK="ftp irc sip h323 amanda proto_gre pptp rtsp tftp"
#	local LIST_JUMP="CONNMARK CLASSIFY ULOG"
#	local LIST_SCHEDULER="cbq"			# tc-scheduler: [C]lass [B]ased [Q]ueueing | http://man-wiki.net/index.php/8:tc-cbq

	_list_add_prefix ()
	{
		local PREFIX="$1"
		local LIST="$2"
		local OBJ

		for OBJ in $LIST; do {
			echo -n "${PREFIX}${OBJ} "
		} done
	}

#	LIST_MATCH="$(		_list_add_prefix ipt_		"$LIST_MATCH"		)"
	LIST_CONNTRACK="$(	_list_add_prefix ip_conntrack_	"$LIST_CONNTRACK" 	)"	
#	LIST_JUMP="$(		_list_add_prefix ipt_		"$LIST_JUMP"		)"
#	LIST_SCHEDULER="$(	_list_add_prefix sch_		"$LIST_SCHEDULER"	)"
	
	for MODULE in ${LIST_MATCH} ${LIST_CONNTRACK} ${LIST_JUMP} ${LIST_SCHEDULER}; do {
		_system insmod $MODULE
	} done
}

_pfilter_user_splash_add ()
{
	local FUNC="pfilter_user_splash_add"
	local MYHNA="$( uci get olsrd.@Hna4[0].netaddr )/$( _net mask2cidr $( uci get olsrd.@Hna4[0].netmask ) )"

	eval $( _ipsystem do | grep ^WIFI_IP= )

	_log do $FUNC daemon info "[START] preparing splash"

	_ipt -t mangle -A PREROUTING -p udp --sport 68 --dport 67 -d 255.255.255.255 -j ACCEPT		# DCHP requests to internal server
	_ipt -t mangle -A PREROUTING ! -s $MYHNA ! -d $MYHNA                         -j ACCEPT		# forwarding internet from other nodes
	_ipt -t mangle -A PREROUTING ! -s $MYHNA                                     -j ACCEPT          # from other nodes to me
	
	# _ipt -t mangle -A PREROUTING ! -d $MYHNA                                     -j ACCEPT          # dest = internet

	_ipt -t mangle -A PREROUTING -i tap+ -d $WIFI_IP			-j ACCEPT		# picopeer from tunnel
	_ipt -t mangle -A PREROUTING -s $WIFINET/$WIFIPRE -d $WIFINET/$WIFIPRE	-j ACCEPT		# picopeer small (myhna2myhna)
	_ipt -t mangle -A PREROUTING -s $WIFI_IP -d $WIFI_IP			-j ACCEPT		# picopeer big ("10.63.17.1/8")
	
	_ipt -t mangle -A PREROUTING -p udp --dport 698                              -j ACCEPT		# OLSR incoming
	_ipt -t mangle -A PREROUTING -p tcp -m multiport --dports 80,443             -j MARK --set-mark $( _pfilter proto2id REDIRECT )
	_ipt -t mangle -A PREROUTING -m mark --mark 0                                -j MARK --set-mark $( _pfilter proto2id REJECT )

	_ipt -t nat    -A PREROUTING -m mark --mark $( _pfilter proto2id REDIRECT )       -j REDIRECT

	_log do $FUNC daemon info "[READY] splash prepared"
}

_pfilter_rules_accept_all ()
{
	local FUNC="pfilter_rules_accept_all"
	local CHAIN MODE
	local ARG="$1"				# off|on

	if [ "$ARG" = "off" ]; then
		MODE="D"			# delete

		_pfilter user_splash_remove dummy_arg dummy_arg do_pending_jobs

		_log do $FUNC daemon info "counter: $( cat /tmp/$FUNC )"

		_watch counter "/tmp/$FUNC" decrement 1 min 0 || {			# allow multiple on's but deny more off's than on's
			_pfilter status mark_up
			_log do $FUNC daemon info "already off, ignoring call"

			if [ "$( uci get system.@weblogin[0].enabled )" = "1" ]; then
				iptables -t nat -nL PREROUTING | head -n3 | grep -q ^olsr_in && {
					_log do $FUNC daemon info "[OK] olsr_in is first rule in nat_prerouting"
					return
				}
			else
				return
			fi
		}
	else
		MODE="I"			# default = insert

		_watch counter "/tmp/$FUNC" increment 1
	fi

	for CHAIN in filter mangle; do {
		_log do $FUNC daemon debug "table '$CHAIN', switching '$ARG'"
		
		_ipt -t $CHAIN -$MODE INPUT              -j ACCEPT
		_ipt -t $CHAIN -$MODE FORWARD            -j ACCEPT
		_ipt -t $CHAIN -$MODE OUTPUT             -j ACCEPT
		_ipt -t $CHAIN -$MODE PREROUTING  -t nat -j ACCEPT
	      # _ipt -t $CHAIN -$MODE POSTROUTING -t nat -j ACCEPT	# let masquerading work
		_ipt -t $CHAIN -$MODE OUTPUT      -t nat -j ACCEPT
	} done

	[ "$ARG" = "off" ] && {
		[ "$( _system uptime min )" -gt 360 ] && {
			iptables -t nat -nL PREROUTING | head -n3 | grep -q ^olsr_in || {
				_log do $FUNC daemon alert "[ERR] olsr_in is NOT first rule in nat_prerouting, rebooting"
				sleep 15
				reboot
			}
		}
	}
}

_pfilter_rules_olsr_ignore_ignored_neighs ()		# ignoring neighs is really annoying, we delete the rules and autoconvert this to LQ_MULT x 0.1
{
	local LIST_IGNORE=$( uci get firewall.@ignoreolsr[0].ip )
	local FILL IP
	
	IFS=";"
	for IP in $LIST_IGNORE; do {
		_ipt -D INPUT -i $WIFIDEV -s $IP -p udp --sport 698 -j DROP

		uci get olsrd.@Interface[0].lqmult | grep -q "$IP:" || {
		
			FILL=";"
			[ -z "$( uci get olsrd.@Interface[0].lqmult )" ] && FILL=""
			_nvram set ff_lqmult "$( uci get olsrd.@Interface[0].lqmult )${FILL}${IP}:0.1"		# appending to LQmult-list
		}
	} done
	unset IFS
}

_pfilter_rules_olsr_whitelist_fetch ()
{
	local FUNC="pfilter_rules_olsr_whitelist_fetch"
	local FILE="/tmp/olsr_whitelist_fresh"
	
	_log do $FUNC daemon info "fetching"

	wget -qO $FILE "$( _links firmware_url_get olsr_whitelist )"	# <unixtime>-Tags at first and last line

	local TAG1="$( head -n 1 $FILE )"
	local TAG2="$( tail -n 1 $FILE )"

	if [ -n "$TAG1" ] && [ "$TAG1" = "$TAG2" ]; then
		_log do $FUNC daemon info "went fine, sanitizing"
		sed -e '/[<>]/d' -e 's/[^A-Fa-f0-9:,]//g' $FILE >/tmp/olsr_whitelist		# removing lines with "<unixtime>" and sanitize LF/CR
	else											# results in: "nodenumber,mac (can be empty)
		_log do $FUNC daemon info "abort - something went wrong"
	fi

	rm $FILE
}

_pfilter_rules_olsr_whitelist_update ()				# fixme! new MACs are never added until fw-full-restart (!)
{
	local FUNC="pfilter_rules_olsr_whitelist_update"

	[ ! -e "/tmp/olsr_whitelist" ] && {
		_log do $FUNC daemon debug "no whitelist - no update"
		return
	}
	
	local N=0
	local ESTIMATED="$(( 8 * $( _file lines /tmp/olsr_whitelist ) / 10 ))"	# counting lines and multipling 0.8 seconds for each line for time-message in syslog
	
	_log do $FUNC daemon info "inserting new rules (needs up to $ESTIMATED seconds)"

	while read LINE; do {							# each line is: "nodenumber,mac" - mac can be empty
		
		IP="$( _ipsystem do ${LINE%,*} | sed -n 's/^WIFIADR=\(.*\)/\1/p' )"
		
		_ipt -nL olsr_in_whitelist | grep -q "$( _sanitizer do "$IP" esacpe_dots )" || {	# IP not in list yet?
			MAC="${LINE#*,}"
		
			MACFILTER=""		
			test -n "$MAC" && MACFILTER="-m mac --mac-source $MAC"
				
			let N+=1
			_ipt -A olsr_in_whitelist -s $IP $MACFILTER -j olsr_in_wifi_valid
		}

	} done </tmp/olsr_whitelist

	_ipt -D olsr_in_whitelist -j ACCEPT 2>/dev/null			       # deleting accept. of all packets, activating whitelist
	
	_log do $FUNC daemon info "installed $N rules"
}

_pfilter_rules_olsr_whitelist_optimize ()
{
	local FUNC="pfilter_rules_olsr_whitelist_optimize"
	local  NO_NEIGH="/tmp/we_have_no_olsr_neighbour.txt"
	touch $NO_NEIGH
	
	[ ! -e "/tmp/olsr_whitelist" ] && return

	_log do $FUNC daemon info "start"

	iptables -nL olsr_in_whitelist 2>/dev/null | grep -q ACCEPT || {
		_ipt -I olsr_in_whitelist -j ACCEPT				# temp. accept. of all packets
	}

	iptables -nxvL olsr_in_whitelist |
	 sed -e '/^ *0/d' -e '/valid/!d' -e 's/\*/_/g' |			# filtering packetcount 0 and stars,
          sort |
           while read LINE; do                                                                                                      
		set $LINE
                
                IP="$8"
                MAC="$11"                                                                                                                      
                HOST="$( _net ip2dns $IP )"
                NODE="$( _ipsystem do $IP )"
						                                                    
                _log do pfilter daemon info "(_pfilter rules_olsr_whitelist_optimize) moveup: $IP node_$NODE $HOST ${1}_packets)"

		test -e $NO_NEIGH && rm -f $NO_NEIGH

                if [ -z "$MAC" ]; then                                                         		# without MAC
                        _ipt -D olsr_in_whitelist                      -s $IP -j olsr_in_wifi_valid        # delete old rule
                        _ipt -I olsr_in_whitelist --set-counters $1 $2 -s $IP -j olsr_in_wifi_valid        # insert new rule at the beginning, reinsert old values
                else                                                                                                                                   
                        _ipt -D olsr_in_whitelist                      -s $IP -m mac --mac-source $MAC -j olsr_in_wifi_valid
                        _ipt -I olsr_in_whitelist --set-counters $1 $2 -s $IP -m mac --mac-source $MAC -j olsr_in_wifi_valid
                        
                        _net arp_permanent $IP $MAC wifi
                fi                                 
        done      

	_ipt -D olsr_in_whitelist -j ACCEPT 2>/dev/null 						# removing temp. accept. of all packets

	[ -e "$NO_NEIGH" ] && {
		_log do pfilter daemon info "(_pfilter rules_olsr_whitelist_optimize) really no neighbours!"
		_pfilter rules_olsr_whitelist_bypass 
	}
}

_pfilter_rules_olsr_whitelist_errorcheck ()
{
	local FUNC="pfilter_rules_olsr_whitelist_errorcheck"
	local LINES_IN_WL_CHAIN="$( iptables -nxvL olsr_in_whitelist | fgrep all | wc -l )"		# the grep removes chain-headers
	local LINES_IN_WL_FILE="$( _file lines "/tmp/olsr_whitelist" )"
	local OUT="false"

	_log do $FUNC daemon info "$OUT (lines in: $LINES_IN_WL_FILE - lines real: $LINES_IN_WL_CHAIN)"

	if [ ${LINES_IN_WL_CHAIN:-0} -lt ${LINES_IN_WL_FILE:-0} ]; then
		return 0
	else
		return 1
	fi
}

_pfilter_rules_olsr_whitelist_bypass ()
{
	_log do pfilter daemon info "(_pfilter rules_olsr_whitelist_bypass ) executing"	

	_ipt -I olsr_in_whitelist -j ACCEPT
}

_pfilter_rules_olsr_control ()
{
	local FUNC="pfilter_rules_olsr_control"
	local MYHNA="$( uci get olsrd.@Hna4[0].netaddr )/$( _net mask2cidr $( uci get olsrd.@Hna4[0].netmask ) )"

	_log do pfilter daemon info "($FUNC) Installing management"

	rm -f "/tmp/olsr_whitelist"									# to be sure, that this list must be reread

	# ----- creating user-chains: -----

	_ipt -N olsr_in
	_ipt -N olsr_in_wifi
	_ipt -N olsr_in_wire
	_ipt -N olsr_in_sanitizer
	_ipt -N olsr_in_malformed
	_ipt -N olsr_in_homebrew
	_ipt -N olsr_in_whitelist
	_ipt -N olsr_in_wifi_valid
	_ipt -N olsr_in_wifi_invalid
	_ipt -N olsr_in_wire_valid

	_ipt -N olsr_out
	_ipt -N olsr_out_wifi
	_ipt -N olsr_out_wire

	_ipt -t nat -N olsr_in
	_ipt -t nat -N olsr_out

	# ----- incoming OLSR: -----
	
	_ipt -A PREROUTING -t nat -p udp --dport 698   -j olsr_in				# to me
	_ipt -A INPUT             -p udp --dport 698   -j olsr_in				# to me

	_ipt -A olsr_in -t nat			       -j ACCEPT				# no further parsing in table nat

	_log do $FUNC daemon info "accepting all packets, whitelist is deprecated"
	_ipt -A olsr_in					-j ACCEPT				# fixme! this completely disables the whitelist

	_ipt -A olsr_in -i $WIFIDEV                    -j olsr_in_wifi  			# wifi in
	_ipt -A olsr_in                                -j olsr_in_wire				# wire in
	
	_ipt -A olsr_in_wifi                           -j olsr_in_sanitizer			# are packets good?
	_ipt -A olsr_in_wifi                           -j olsr_in_whitelist			# try to pass whitelist, or...
	_ipt -A olsr_in_wifi                           -j olsr_in_wifi_invalid			# away
	
	_ipt -A olsr_in_wire -i tap+	-j ACCEPT				# from tap?
	_ipt -A olsr_in_wire -i tun+	-j ACCEPT				# from tun?
	_ipt -A olsr_in_wire -i $LANDEV	-j olsr_in_sanitizer			# from lan?
	_ipt -A olsr_in_wire -i $LANDEV	-j olsr_in_wire_valid			# from lan and sanitized
	_ipt -A olsr_in_wire		-j olsr_in_sanitizer			# must be WANDEV...
	_ipt -A olsr_in_wire		-j olsr_in_wire_valid			# count all valid
	
	_ipt -A olsr_in_sanitizer -s $MYHNA				-j olsr_in_homebrew		# selfgenerated packets from me to me
	_ipt -A olsr_in_sanitizer -s $WIFINET/$WIFIPRE		-p udp --sport 698 -j RETURN	# all ok, back to further parsing (later: -d 255.255.255.255)
	_ipt -A olsr_in_sanitizer -i $WIFIDEV			-j RETURN			# from WIFI
	_ipt -A olsr_in_sanitizer -i $LANDEV  -p udp --sport 698	-j RETURN			# from LAN
	_ipt -A olsr_in_sanitizer -i tap+     -p udp --sport 698	-j RETURN			# from tunnel, not that restrictiv
	_ipt -A olsr_in_sanitizer					-j olsr_in_malformed		# something is wrong
	
	_ipt -A olsr_in_malformed -m limit --limit 1/hour -j LOG --log-prefix "olsr_in_malformed: "  # first log and then...
	_ipt -A olsr_in_malformed                      -j DROP					# better not parse these packets
	
	_ipt -A olsr_in_homebrew -i $WIFIDEV	       -j DROP                                  # from WIFI? we don't need these packets
	_ipt -A olsr_in_homebrew -i $LANDEV            -j DROP					# from LAN?
	_ipt -A olsr_in_homebrew                       -j DROP                                  # must be from WAN
	
	_ipt -A olsr_in_whitelist			       -j ACCEPT				# later we have to fill this chain with MAC/IP-tupels

	_ipt -A olsr_in_wifi_valid                     -j ACCEPT				# all went ok, let olsrd parse it
	_ipt -A olsr_in_wire_valid                     -j ACCEPT				# the same for wire

	_ipt -A olsr_in_wifi_invalid -m limit --limit 3/hour -j LOG --log-prefix "olsr_in_wifi_invalid: "	# not useable
	_ipt -A olsr_in_wifi_invalid                 -j DROP				        # better not parse these packets

	# ----- outgoing OLSR: -----
	
	_ipt -A POSTROUTING -t nat -p udp --dport 698  -j olsr_out				# from me

	#								# gives errors: 'kern.err olsrd[3923]: OLSR: sendto IPv4 Operation not permitted'
	# [ "$( _wifi mode )" != "adhoc" ] && {				# fixme! must be device-specific
	#	[ "$( uci get system.@profile[0].name )" != "versilia_ap" ] && {
	#		_log do $FUNC daemon info "deactivating wifi-olsr"
	#		_ipt -A OUTPUT -o $WIFIDEV -p udp --dport 698 -j DROP		# in AP-mode, keep air clean
	#	}
	# }

	_ipt -A OUTPUT -p udp --dport 698	-j olsr_out		# from me

	_ipt -A olsr_out -t nat		-j ACCEPT		# no further parsing in table nat
	_ipt -A olsr_out -o $WIFIDEV	-j olsr_out_wifi	# wifi out
	_ipt -A olsr_out			-j olsr_out_wire	# wire out

	_ipt -A olsr_out_wifi		-j ACCEPT		# maybe doing some statistics here (size, speed ...)
	_ipt -A olsr_out_wire		-j ACCEPT		# maybe doing some statistics here (size, speed ...)
}

_pfilter_l7proto_list ()
{
	local	LAYER7="ntp,123 shoutcast,8000 http,80 irc,6665:6669 ftp,21 ssh,22 telnet,23 dns,53 pop3,110 nntp,119 imap,143 validcertssl,443 ssl,993"
		LAYER7="$LAYER7 smtp,25 msnmessenger,1863 rdp,3389 aim,5190 jabber,5222"
		LAYER7="$LAYER7 yahoo,5050 vnc,5900:5902 halflife2-deathmatch,7001 sip,0 lpd,0 skypetoskype,0 skypeout,0"

		# quake-halflife,26970

	echo -n "$LAYER7"
}

_pfilter_rules_walledgarden ()				# fixme! this must be profile-sensitive
{
	local FUNC="pfilter_rules_walledgarden"
	local option="$1"
	local TABLE="walled_garden"
	local ENTRY WALLED_GARDEN

	[ -z "$option" ] && {
		WALLED_GARDEN="
			141.54.160.24/32	ping01/mediathek
			141.54.1.1/32		BUW-DNS
			141.1.1.1/32		DFN
			85.25.251.231/32	vorratsdatenspeicherung.de
			82.149.225.169/32	wiki.vorratsdatenspeicherung.de
			141.54.160.48/32	m18.uni-weimar.de
			87.118.106.19/32	www.weimarnetz.de
			77.87.48.19/32		www.weimarnetz.de_newserver
			88.198.146.230/32	wireless.subsignal.org
			"

		#	92.123.193.15/32	http://www.apple.com/library/test/success.html_some_iPhones_needs_this
	}

	_ipt -t mangle -N $TABLE

	for ENTRY in $WALLED_GARDEN; do {				# accepting marked packets is done in main_framework
		
		if _sanitizer do "${ENTRY%/*}" ip4 check ; then		# we have to filter IPs from comments (only check before '/')
		
			_log do $FUNC daemon info "no fence for '$ENTRY'"
		
			_ipt -t mangle -A $TABLE -s $ENTRY -j ACCEPT
			_ipt -t mangle -A $TABLE -d $ENTRY -j ACCEPT
		else
			_log do $FUNC daemon info "comment: $ENTRY"
		fi
	} done

	_ipt -t mangle -A PREROUTING -j $TABLE
}

_pfilter_rules_nat_no_wificlients ()
{
	local FUNC="pfilter_rules_nat_no_wificlients"
	local WIFI_DHCP_NET
	local WIFI_IP_1ST
	local WIFI_DHCP_PRE
	
	eval $( _ipsystem do | grep ^WIFI_IP_1ST   )
	eval $( _ipsystem do | grep ^WIFI_DHCP_PRE )
	WIFI_DHCP_NET="$WIFI_IP_1ST/$WIFI_DHCP_PRE"

	[ -z "$WIFI_DHCP_NET" ] && return
	
	_log do $FUNC daemon info "removing rules"

	_ipt -D POSTROUTING -t nat -s $WIFI_DHCP_NET -j MASQUERADE
}

_pfilter_rules_nat_dns_enforce_own ()
{
	local FUNC="pfilter_rules_nat_dns_enforce_own"
	local DNS_FIRST_SERVER="$( uci get dhcp.@dnsmasq[0].server | cut -d ';' -f1 )"

	_net ip4_is_private "$DNS_FIRST_SERVER" && {
		_log do $FUNC daemon info "enforcing server '$DNS_FIRST_SERVER' for all"

		_ipt -t nat -A PREROUTING -p udp --dport 53 ! -d $DNS_FIRST_SERVER -j DNAT --to-destination $DNS_FIRST_SERVER
	}
}

_pfilter_rules_nat_install ()		# fixme! also masq traffic from local lan to internet during startup (atm only local wifi gets masq)
{
	local INETOFFER="$( _net local_inet_offer )"

	case $INETOFFER in
		lan)
			_pfilter rules_nat_inetoffer_lan
		;;
		tun|tun0)
			_ipt -t nat -A POSTROUTING -o tun+ ! -d $WIFINET/$WIFIPRE -j MASQUERADE
		;;
		tap)
			_ipt -t nat -A POSTROUTING -o tap+ ! -d $WIFINET/$WIFIPRE -j MASQUERADE
		;;
		wan)
			_ipt -t nat -A POSTROUTING -o $WANDEV ! -d $WIFINET/$WIFIPRE -j MASQUERADE
		;;
		wifi)
			_ipt -t nat -A POSTROUTING -o $WIFIDEV -j MASQUERADE
		;;
		pppoe)
			_ipt -t nat -A POSTROUTING -o ppp+ ! -d $WIFINET/$WIFIPRE -j MASQUERADE
		;;
		*)	
			# should'nt break anything: sometimes WANDEV is not up yet when packetfilter starts up
			
			WANDEV="$( uci get network.wan.ifname )"
			[ -n "$WANDEV" ] && _ipt -t nat -A POSTROUTING -o ${WANDEV} ! -d $WIFINET/$WIFIPRE -j MASQUERADE
			_ipt -t nat -A POSTROUTING -o ppp+ ! -d $WIFINET/$WIFIPRE -j MASQUERADE
		;;
	esac
	
	_pfilter rules_nat_no_wificlients
	_pfilter rules_nat_wifi_roaming
	_pfilter rules_portfw_install
	_pfilter rules_nat_dns_enforce_own
}

_pfilter_stats_chain_show ()
{
	local FUNC="pfilter_stats_chain_show"
	local TABLE="$1"
	local CHAIN="$2"
	local LINE
	
	[ -z "$CHAIN" ] && {		# defaults to 'filter' like _ipt-usage
		TABLE="filter"
		CHAIN="$1"
	}
	
	iptables -t $TABLE -nxvL $CHAIN | while read LINE; do {
		_log do $FUNC daemon debug "$LINE"
	} done
}
