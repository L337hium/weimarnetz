# iw phy phy0 interface add moni0 type monitor; horst -i moni0; iw dev moni0 del

# cat /sys/kernel/debug/ieee80211/phy0/ath9k/wiphy

# Idee, wie man mit mehreren wlan-karten klarkommt: 
#    Erstes WIFI_DEV steht sowohl in normaler Variablenliste,
#    als auch in /tmp/wifi_$DEV zum includen. So werden Operationen
#    auf alle Elemente in der Liste gemacht:
#    (es muss also nur was included werden, wenn es mehrere wireless-karten gibt)
#    (bei einer wlan-karte gibt es kein $WIFI_DEV_NEXT)
#
# for WIFIDEV in $LIST_WIFIDEVS; do {
#	do_some_stuff_with_normal_vars
#	[ -n "$WIFI_NEXT" ] && . $WIFI_NEXT	# inluding VAR-set for next WIFI_DEV
# } done					# (last entry must point to first-device)


_wifi_show_station_traffic()
{
	local mac="$1"
	local wifidev="$2"
	local rx_old="$3"
	local tx_old="$4"
	local uptime_old="$5"
	local uptime="$( _system uptime centisec )"
	local line rx tx tx_human rx_human rx_diff tx_diff uptime_diff unit

	# while :; do eval $( _wifi show_station_traffic "$mac" $WIFIDEV $rx $tx $up ); sleep 60; done

	iw dev "$wifidev" station get "$mac" |
	 while read line; do {
		case "$line" in
			*"rx bytes:"*)
				set $line
				rx="$3"
			;;
			*"tx bytes:"*)
				set $line
				tx="$3"

				rx_human="$( _sanitizer do "$rx" number_humanreadable )"
				tx_human="$( _sanitizer do "$tx" number_humanreadable )"

				if [ -n "$rx_old" ]; then
					rx_diff=$(( $rx - $rx_old ))
					tx_diff=$(( $tx - $tx_old ))
				else
					rx_diff=0
					tx_diff=0
				fi

				if [ -n "$uptime_old" ]; then
					unit="bytes/s"
					uptime_diff=$(( $uptime - $uptime_old ))

					rx_diff=$(( ($rx_diff * 100) / $uptime_diff ))
					tx_diff=$(( ($tx_diff * 100) / $uptime_diff ))
				else
					unit="bytes"
				fi

				echo "echo '# overall: tx/rx: $rx_human/$tx_human  diff_rx/tx: $rx_diff/$tx_diff $unit';"
				echo "rx=$rx; tx=$tx; up=$uptime;"
			;;
		esac
	} done
}

_wifi_minstrel_extract_raw_and_real_txrate_from_neigh_with_highest_success_rate()	# fixme! rename and rework for: _wifi_minstrel_effective_throughput_rate_tupel_max
{
	local mac="$1"		# or IP
	local option="$2"	# debug
	local wifi_dev="${3:-$WIFIDEV}"
	local ip

	case "$mac" in
		*:*)
			ip="$( _net mac2ip "$mac" )"
		;;
		*)
			_sanitizer do "$mac" ip4 check && {
				ip="$mac"
				mac="$( _net ip2mac $mac )"
			}
		;;
	esac

	[ -e "/tmp/OLSR/LINKS.sh" ] && {
		eval $( fgrep "REMOTE=${ip};" "/tmp/OLSR/LINKS.sh" )
		echo -n "lq=$LQ;nlq=$NLQ;cost=$COST;"
	}

	local file="/sys/kernel/debug/ieee80211/phy0/netdev:${wifi_dev}/stations/$mac/rc_stats"
	local line result targetline rate throughput efficiency system
	local max=0

	[ -e "$file" ] || {
		echo "ip=$ip;"
		return 1
	}

	[ "$option" = "debug" ] && {
		_log do minstrel_out daemon debug "output of $file"
		cat "$file"
		echo
	}

	percent()
	{
		if   [ "$1" -lt 100 ]; then
			echo "0"
		elif [ "$2" = "0" ]; then
			echo "0"
		else
			echo "$(( ( $1 * 100 ) / $2 ))"
		fi
	}

	while read line; do {

		case "$line" in
			Type*|type*)
				continue
			;;
			T*|t*)			# only use lines with highest/2nd-highest rate
				set $line
			;;
			"HT20/LGI T"*|"HT20/SGI T"*|"HT40/LGI T"*|"HT40/SGI T"*)
				system="n"
				set $line
				shift
			;;
			"HT20/LGI  t"*|"HT20/SGI  t"*|"HT40/LGI  t"*|"HT40/SGI  t"*)
				system="n"
				set $line
				shift
			;;
			*)
				continue
			;;
		esac

# 		logger -s "interesting line: 1: $1 2: $2 3: $3 4:$3 5: $5 6: $6 7: $7 8: $8 9: $9 10: ${10}"

		case "$2" in
			1|2|5.5|11|6|9|12|18|24|36|48|54|*MCS*)

				if [ -n "$9" ]; then
					result="$( percent "$8" "$9" )"
				else
					result="$( percent "$7" "$8" )"
				fi

				[ $result -gt $max ] && {
					max=$result
					targetline="$line"
				}
			;;
			*)
				case "$3" in
					ewma|count*)
						:
					;;
					*)
						if [ -n "${10}" ]; then
							result="$( percent "$9" "${10}" )"
						else
							result="$( percent "$7" "$8" )"
							
						fi
						
						[ $result -gt $max ] && {
							max=$result
							targetline="$line"
						}
					;;
				esac
			;;
		esac

	} done <$file

	[ -n "$targetline" ] && {

		set $targetline
# 		logger -s "TL 1: $1 2: $2 3: $3 4:$3 5: $5 6: $6 7: $7 8: $8 9: $9"

		case "$2" in
			*MCS*)
				system="n"
				rate="$2"
				throughput="$3"
			;;
			1|2|5.5|11|6|9|12|18|24|36|48|54)
				system="g"
				rate="$2"
				throughput="$3"
			;;
			*)
				rate="$3"
				throughput="$4"
			;;
		esac

		[ "$rate" = "0" ] || {

#			logger -s "rate: $rate"

			case "$rate" in
				*MCS*)
					system="n"
					rate="$( _wifi math_mcs2rate "$1" "$1" "$rate" "$option" )"
#					logger -s "rate: $rate"
				;;
				*)
					system="g"
				;;
			esac

			if [ "${throughput%.*}" = "0" ]; then
				efficiency="${throughput#*.}"				# 0.9 -> 9
			else
				efficiency="${throughput%.*}${throughput#*.}"		# 42.6 -> 426
			fi

			case "$rate" in
				*"."*)
					efficiency="$(( ( $efficiency * 100 ) / ${rate//./} ))"		# [percent]
				;;
				*)
					efficiency="$(( ( $efficiency * 10 ) / $rate ))"		# [percent]
				;;
			esac
		}
	}

	echo "txrate=${rate:-0};txthroughput=${throughput:-0};efficiency=${efficiency:-0};system=${system};ip=$ip"
}

_wifi_math_mcs2rate()			# fixme! output spatial streams, coding rate, modulation type?
{
	local funcname="wifi_math_mcs2rate"
	local channel_width="$1"		# e.g. HT20/HT40
	local guard_interval_type="$2"		# e.g. LGI/SGI = 400/800ns
	local mcs_index="$3"			# e.g. 0...15		# fixme! should work for 0...31
	local debug="$4"
	local rate
	local spatial_streams coding_rate modulation_type avg_ampdu_length	# fixme!

	case "$channel_width" in
		*20*) channel_width="20" ;;
		*40*) channel_width="40" ;;
	esac

	case "$guard_interval_type" in
		*SGI*) guard_interval_type="short" ;;
		*LGI*) guard_interval_type="long" ;;
	esac

	case "$mcs_index" in
		*[0-9]) mcs_index="${mcs_index#*MCS}" ;;	# MCS12 -> 12
	esac

	[ -n "$debug" ] && {
		case "$mcs_index" in
				0|1|2|3|4|5|6|7) spatial_streams="1" ;;
			  8|9|10|11|12|13|14|15) spatial_streams="2" ;;
			16|17|18|19|20|21|22|23) spatial_streams="3" ;;
			24|25|26|27|28|29|30|31) spatial_streams="4" ;;
		esac

		case "$mcs_index" in
			  0|1|3|8|9|11|16|17|19|24|25|27) coding_rate="1/2" ;;
					      5|13|21|29) coding_rate="2/3" ;;
			2|4|6|10|12|14|18|20|22|26|28|30) coding_rate="3/4" ;;
					      7|15|23|31) coding_rate="5/6" ;;
		esac

		case "$mcs_index" in
						  0|8|16) modulation_type="BPSK" ;;
				    1|2|9|10|17|18|24|25) modulation_type="QPSK" ;;
				   3|4|11|12|19|20|27|28) modulation_type="16QAM" ;;
			5|6|7|13|14|15|21|22|23|29|30|31) modulation_type="64QAM" ;;
		esac

		_log do $funcname daemon debug "channel_width: $channel_width guard_interval_type: $guard_interval_type mcs_index: $mcs_index spatial_streams: $spatial_streams coding_rate: $coding_rate modulation_type: $modulation_type"
	}

	case "$channel_width" in
		20)
			case "$guard_interval_type" in
				long)
					case "$mcs_index" in
						0) rate="6.5" ;;
						1) rate="13" ;;
						2) rate="9.5" ;;
						3) rate="26" ;;
						4) rate="39" ;;
						5) rate="52" ;;
						6) rate="58.5" ;;
						7) rate="65" ;;
						8) rate="13" ;;
						9) rate="26" ;;
						10) rate="39" ;;
						11) rate="52" ;;
						12) rate="78" ;;
						13) rate="104" ;;
						14) rate="117" ;;
						15) rate="130" ;;
					esac
				;;
				short)
					case "$mcs_index" in
						0) rate="7.2" ;;
						1) rate="14.4" ;;
						2) rate="21.7" ;;
						3) rate="28.9" ;;
						4) rate="43.3" ;;
						5) rate="57.8" ;;
						6) rate="65" ;;
						7) rate="72.2" ;;
						8) rate="14.4" ;;
						9) rate="28.9" ;;
						10) rate="43.3" ;;
						11) rate="57.8" ;;
						12) rate="86.7" ;;
						13) rate="115.6" ;;
						14) rate="130" ;;
						15) rate="144.4" ;;
					esac
				;;
			esac
		;;
		40)
			case "$guard_interval_type" in
				long)
					case "$mcs_index" in
						0) rate="13.5" ;;
						1) rate="27" ;;
						2) rate="40.5" ;;
						3) rate="54" ;;
						4) rate="81" ;;
						5) rate="108" ;;
						6) rate="121.5" ;;
						7) rate="135" ;;
						8) rate="27" ;;
						9) rate="54" ;;
						10) rate="81" ;;
						11) rate="108" ;;
						12) rate="162" ;;
						13) rate="216" ;;
						14) rate="243" ;;
						15) rate="270" ;;
					esac
				;;
				short)
					case "$mcs_index" in
						0) rate="15" ;;
						1) rate="30" ;;
						2) rate="45" ;;
						3) rate="60" ;;
						4) rate="90" ;;
						5) rate="120" ;;
						6) rate="135" ;;
						7) rate="150" ;;
						8) rate="30" ;;
						9) rate="60" ;;
						10) rate="90" ;;
						11) rate="120" ;;
						12) rate="180" ;;
						13) rate="240" ;;
						14) rate="270" ;;
						15) rate="300" ;;
					esac
				;;
			esac
		;;
	esac

	echo "$rate"
}

_wifi_tx_and_rx ()		# ARG1 = NETWORK_DEV e.g. WIFI_DEV
{
	# WIFI_RX_BYTES=1665694551
	# WIFI_RX_PACKETS=22019893
	# WIFI_RX_ERRORS=0
	# WIFI_RX_FRAMES=109127
	# WIFI_TX_BYTES=2572111365
	# WIFI_TX_PACKETS=22193801
	# WIFI_TX_ERRORS=3

	local FILE="/proc/net/dev"

	sed -n "s/^.*$1: *\([0-9]*\) *\([0-9]*\) *\([0-9]*\) *[0-9]* *[0-9]* *\([0-9]*\) *[0-9]* *[0-9]* *\([0-9]*\) *\([0-9]*\) *\([0-9]*\) .*/WIFI_RX_BYTES=\1\nWIFI_RX_PACKETS=\2\nWIFI_RX_ERRORS=\3\nWIFI_RX_FRAMES=\4\nWIFI_TX_BYTES=\5\nWIFI_TX_PACKETS=\6\nWIFI_TX_ERRORS=\7/p" "$FILE"
}

_wifi_params_iwconfig_status ()		# ARG1 = WIFI_DEV
{
	# WIFI_DEV=eth1
	# WIFI_UPTIME=0
	# WIFI_ESSID='www.freifunk.net (Zugangspunkt)'  	# fixme! single quotes are not correct escaped!
	# WIFI_MODE="Managed"
	# WIFI_FREQ=2442					# in MHz ! -> convert to Channel?
	# WIFI_CHANNEL="$( _wifi math_mhz2channel 2442 )"	# this is converted during 'eval'
	# WIFI_BSSID=00:1D:73:05:0F:59  
	# WIFI_SENSITIVITY="0/3"
	# WIFI_RETRY=off
	# WIFI_RTS=256
	# WIFI_FRAG=off
	# WIFI_QUALITY=52
	# WIFI_QUALITY_MAX=94
	# WIFI_SIGNAL='-43'
	# WIFI_NOISE='-95'
	# WIFI_TXPOWER=20	// only seen with atk9k/mac80211

				# fixme! sometimes iwconfig-output is empty

	/usr/sbin/iwconfig $1 2>/dev/null |
	 sed -ne "s/^.*ESSID:\"\(.*\)\"/WIFI_DEV=$1\nWIFI_UPTIME=0\nWIFI_ESSID='\1'/p" \
	     -ne 's/^.*Mode:\([- a-zA-Z]*[a-zA-Z]\).*Access Point: \(.*\)Tx-Power=\([0-9]*\) dBm.*/WIFI_MODE=\1;WIFI_TXPOWER=\3;/p' \
	     -ne 's/^.*Mode:\([- a-zA-Z]*[a-zA-Z]\).*Frequency:\([0-9]\)\.\([0-9]*\).*Access Point: \(..:..:..:..:..:..\)/WIFI_MODE="\1"\nWIFI_FREQ=\2\3\nWIFI_CHANNEL=\"\$( _wifi math_mhz2channel \2\3 )\"\nWIFI_BSSID=\4/p' \
	     -ne 's/^.*Mode:\([- a-zA-Z]*[a-zA-Z]\).*Frequency:\([0-9]\)\.\([0-9]*\).*Cell: \(..:..:..:..:..:..\)/WIFI_MODE="\1"\nWIFI_FREQ=\2\3\nWIFI_CHANNEL=\"\$( _wifi math_mhz2channel \2\3 )\"\nWIFI_BSSID=\4/p' \
	     -ne 's/^.*Mode:\([- a-zA-Z]*[a-zA-Z]\).*Frequency:\([0-9]\)\.\([0-9]*\).*Cell: Not-Associated/WIFI_MODE="\1"\nWIFI_FREQ=\2\3\nWIFI_CHANNEL=\"\$( _wifi math_mhz2channel \2\3 )\"\nWIFI_BSSID=\4/p' \
	     -ne 's/^.*Mode:\([- a-zA-Z]*[a-zA-Z]\).*Frequency:\([0-9]\)\.\([0-9]*\).*Tx-Power=\([0-9]*\) dBm.*/WIFI_MODE="\1"\nWIFI_FREQ=\2\3\nWIFI_CHANNEL=\"\$( _wifi math_mhz2channel \2\3 )\"\nWIFI_TXPOWER=\4/p' \
	     -ne 's/^.*Mode:\([- a-zA-Z]*[a-zA-Z]\).*Tx-Power=\([0-9]*\) dBm.*/WIFI_MODE=\1;WIFI_TXPOWER=\2;/p' \
	     -ne 's/^.*Bit Rate:.*Tx-Power:.*Sensitivity=\([0-9]*\)\/\([0-9]*\).*/WIFI_SENSITIVITY="\1\/\2"/p' \
	     -ne 's/^.*Retry.\([a-z0-9]*\)[^a-zA-Z0-9]*RTS thr.\([a-z0-9]*\)[^0-9a-zA-Z]*Fragment thr.\([a-z0-9]*\).*/WIFI_RETRY="\1"\nWIFI_RTS="\2"\nWIFI_FRAG="\3"/p' \
	     -ne "s/^.*Link Quality[:=]\([0-9]*\)\/\([0-9]*\).*Signal level[:=]\([-0-9]*\) dBm.*Noise level[:=]\([-0-9]*\) dBm/WIFI_QUALITY=\1\nWIFI_QUALITY_MAX=\2\nWIFI_SIGNAL='\3'\nWIFI_NOISE='\4'/p"
}

_wifi_vendor_and_model ()		# fixme! build lookup-table WIFIDEV -> vendor|model
{
	local WIFI_DEV="$1"

	_wifi vendor_and_model_pci

	case "$HARDWARE" in
		"Linksys WRT54G/GS/GL"|"Buffalo WHR-HP-G54"|"Dell TrueMobile 2300")
		;;
		*)
			_wifi vendor_and_model_usb
		;;
	esac
}

_wifi_vendor_and_model_pci ()			# output can be more than one, how to handle?
{						# ARG1 = WIFI_DEV
	local FILE="/proc/bus/pci/devices"	# evalable_output: WIFI_VENDOR=broadcom;WIFI_MODEL=4318;WIFI_BANDS='b g'

	# Atheros5413 = AR5006X-family = MikroTik RouterBOARD R5H (miniPCI)

	if fgrep -q "0" "$FILE"; then		# dirty but works

		sed	-ne "/168c001b/c\WIFI_VENDOR=atheros ;WIFI_MODEL=5413 ;WIFI_BANDS='a'" \
			-ne "/14e44318/c\WIFI_VENDOR=broadcom;WIFI_MODEL=4318 ;WIFI_BANDS='b g'" \
			-ne "/14e44320/c\WIFI_VENDOR=broadcom;WIFI_MODEL=4306 ;WIFI_BANDS='b g'" \
			-ne "/14e44319/c\WIFI_VENDOR=broadcom;WIFI_MODEL=4319 ;WIFI_BANDS='b g a'" \
			-ne "/168c0012/c\WIFI_VENDOR=atheros ;WIFI_MODEL=5211a;WIFI_BANDS='b g a'" \
			-ne "/168c0013/c\WIFI_VENDOR=atheros ;WIFI_MODEL=5212a;WIFI_BANDS='b g a'" \
			-ne "/168c002a/c\WIFI_VENDOR=atheros ;WIFI_MODEL=AR928X;WIFI_BANDS='a'" \
			"$FILE"
	else
		FILE="/tmp/WIFI_VENDOR_AND_MODEL"

		[ -e "$FILE" ] || {
			if   grep -q "Atheros AR9100 MAC/BB Rev:[0-9a-zA-Z]* AR2133" "/tmp/dmesg.boot"; then
				echo "WIFI_VENDOR=atheros;WIFI_MODEL=2133;WIFI_BANDS='b g'" >"$FILE"
			elif fgrep -q "b43-phy0: Broadcom 5352" "/tmp/dmesg.boot"; then
				echo "WIFI_VENDOR=broadcom;WIFI_MODEL=5352;WIFI_BANDS='b g'" >"$FILE"
			else
				echo "WIFI_VENDOR=unknown;WIFI_MODEL=unknown;WIFI_BANDS='b g'" >"$FILE"
			fi
		}

		cat "$FILE"
	fi
}

_wifi_vendor_and_model_usb ()
{
	# WIFI_VENDOR=ralink;WIFI_MODEL=rt73usb

	sed -ne "/Vendor=148f ProdID=2573/cWIFI_VENDOR=ralink;WIFI_MODEL=rt73usb;WIFI_BANDS='b g'" /proc/bus/usb/devices 2>/dev/null
}

_wifi_driver_version()
{
	local WIFI_DEV="$1"		# fixme! howto connect DEV -> PHY  (DEV -> DRIVER is no problem)
	local VERSION

	VERSION="kmod-ath9k_v$( _software package_version kmod-ath9k )"

	echo "$VERSION"
}

_wifi_phy_uptime()
{
	local wifi_dev="$1"
	local uptime_now="$( _system uptime sec )"
	local last_restart=0
	local file="/tmp/STATS_WIFI_RESTARTS.$wifi_dev.time"

	[ -e "$file" ] && {
		read last_restart <"$file"
	}

	echo $(( $uptime_now - $last_restart ))
}

_wifi_phy_restart()
{
	local funcname="wifi_phy_restart"
	local wifi_dev="$1"
	local reason="${2:-no_reason_given}"
	local prio="${3:-alert}"

	local uptime="up $( _wifi phy_uptime "$wifi_dev" ) sec"
	_watch counter "/tmp/STATS_WIFI_RESTARTS.$wifi_dev" increment 1
	_system uptime sec >"/tmp/STATS_WIFI_RESTARTS.$wifi_dev.time"

	eval $( _wifi tx_and_rx $wifi_dev )
	local vals_rx="rx:bytes/packets/errors/frames $WIFI_RX_BYTES/$WIFI_RX_PACKETS/$WIFI_RX_ERRORS/$WIFI_RX_FRAMES"
	local vals_tx="tx_bytes/packets/errors: $WIFI_TX_BYTES/$WIFI_TX_PACKETS/$WIFI_TX_ERRORS"

	echo "$reason: $uptime $vals_rx $vals_tx" >"/tmp/STATS_WIFI_RESTARTS.$wifi_dev.reason"
	_log do $funcname daemon $prio "working on '$wifi_dev' ($reason) $uptime $vals_rx $vals_tx"

	local line mac adduser
	local userlist="$( _netfilter user_list )"
	while read line; do {
		case "$line" in
			*"$wifi_dev")
				set -- $line
				mac="$4"

				case "$userlist" in
					*"$mac"*)
						adduser="$adduser $mac"
					;;
				esac
			;;
		esac
	} done <"/proc/net/arp"

	# fixme! how to restart a specific interface?
	/sbin/wifi down
	_log sleep $funcname 10 step 1
	_system uptime sec >"/tmp/STATS_WIFI_RESTARTS.$wifi_dev.time"
	/sbin/wifi up | grep -q "PHY for wifi device radio. not found" && {
		_log do $funcname daemon alert "message: PHY for wifi device radioX not found"
		return 1
	}

	grep -q ^"b43 " "/proc/modules" && {
		[ "$( uci get wireless.@wifi-iface[0].mode )" = "adhoc" ] || {
			iw dev $wifi_dev set bitrates legacy-2.4 6 9 12 18 24 36 48 54
		}
	}

	local ip
	for mac in $adduser; do {
		read ip <"/tmp/NETFILTER/MAC2IP/$mac"
		_netfilter make_arp_permanent "$mac" "$ip" "$wifi_dev"
	} done

	local users
	local file="/tmp/TRAFFIC_CONTROL_UP_${wifi_dev}"
	[ -e "$file" ] && {
		read users <"$file"
		_netfilter traffic_control_stop

		for mac in $users; do {
			read ip <"/tmp/NETFILTER/MAC2IP/$mac"
			_netfilter traffic_control_user_add "$ip"
		} done
	}

	_system uptime sec >"/tmp/STATS_WIFI_RESTARTS.$wifi_dev.time"
	return 0
}

_wifi_math_mhz2channel ()		# http://en.wikipedia.org/wiki/Lost_of_WLAN_channels
{
	local o				# idea: add to each freq regdomain/countrycode
					#       and choose corresponding countrycode, which fits channel 8-)
	case $1 in
		2412) o=1 ;;  # 276	# block of 802.11b/g/n-freqs
		2417) o=2 ;;  # 276
		2422) o=3 ;;  # 276
		2427) o=4 ;;  # 276
		2432) o=5 ;;  # 276
		2437) o=6 ;;  # 276
		2442) o=7 ;;  # 276
		2447) o=8 ;;  # 276
		2452) o=9 ;;  # 276
		2457) o=10 ;; # 276
		2462) o=11 ;; # 276
		2467) o=12 ;; # 276
		2472) o=13 ;; # 276
		2484) o=14 ;;

					# block of 802.11y ommited

		5035) o=7 ;;		# block of 802.11a/h/j/n
            504|5040) o=8 ;;
		5045) o=9 ;;		# fixme! mark 'outdoor'-channels
		5055) o=11 ;;
	    506|5060) o=12 ;;
            508|5080) o=13 ;;

	    517|5170) o=34 ;;
	    518|5180) o=36 ;; # 608 
	    519|5190) o=38 ;;
	     52|5200) o=40 ;; # 608
	    521|5210) o=42 ;; #	608	# TURBO.only	# for TURBO, see http://madwifi-project.org/wiki/UserDocs/802.11a_channels
	    522|5220) o=44 ;; # 608
	    523|5230) o=46 ;;
	    524|5240) o=48 ;; # 608
	    525|5250) o=50 ;; # 608	# TURBO.only	# not listed in wikipedia?
	    526|5260) o=52 ;; # 608
	    528|5280) o=56 ;; # 608
	    529|5290) o=58 ;; # 608	# TURBO.only	# not listed in wikipedia?
	     53|5300) o=60 ;; # 608
	    532|5320) o=64 ;; # 608

	     55|5500) o=100 ;; # 276	# iwconfig-output is '55' and means 5500mhz!
	    552|5520) o=104 ;; # 276
	    553|5530) o=106 ;; # 276	# not listed in wikipedia?
	    554|5540) o=108 ;; # 276
	    556|5560) o=112 ;; # 276
	    557|5570) o=114 ;; # 276	# not listed in wikipedia?
	    558|5580) o=116 ;; # 276
	     56|5600) o=120 ;; # 276
	    561|5610) o=122 ;; # 276	# not listed in wikipedia?
	    562|5620) o=124 ;; # 276
	    564|5640) o=128 ;; # 276
	    565|5650) o=130 ;; # 276	# not listed in wikipedia?
	    566|5660) o=132 ;; # 276
	    568|5680) o=136 ;; # 276
	     57|5700) o=140 ;; # 276
		5745) o=149 ;;
	    576|5760) o=152 ;;	# TURBO.only	# not listed in wikipedia?	# BFWA
		5765) o=153 ;;							# BFWA
		5785) o=157 ;;							# BFWA
	     58|5800) o=160 ;;	# TURBO.only	# not listed in wikipedia?	# BFWA
		5805) o=161 ;;							# BFWA
		5825) o=165 ;;							# BFWA
	    583|5830) o=166 ;;							# BFWA
	        5835) o=167 ;;							# BFWA
	    584|5840) o=168 ;;							# BFWA
		5845) o=169 ;;							# BFWA
	    585|5850) o=170 ;;							# BFWA
		5855) o=171 ;;							# BFWA
	    586|5860) o=172 ;;							# BFWA
		5865) o=173 ;;							# BFWA
	    587|5870) o=174 ;;							# BFWA
		5875) o=175 ;;							# BFWA
		
		4915) o=183 ;;
	    492|4920) o=184 ;;
		4925) o=185 ;;
		4935) o=187 ;;
	    494|4940) o=188 ;;
		4945) o=189 ;;
	    496|4960) o=192 ;;
	    498|4980) o=196 ;;
					# wl also knows: 200, 204, 208, 212, 216
					# oswave.com -> 220/6100mhz, 234...250 (4920...5000mhz), 1...6 (5005....5030)
					
		   *) o=0 ;;		# fixme! till we inserted all freqs
	esac

	echo -n "$o"
}

_wifi_assoclist ()		# OUT1: list of associated mac_adresses
{
	return 0
}

_wifi_probe_mode_infrastructure ()		# fixme! respect WIFI_DEV
{
	local WIFI_DEV="$1"
	local SWITCH="$2"	# 'config' or <empty>
	local WIFI_MODE

	if [ "$SWITCH" = "config" ]; then

		case "$( uci get wireless.@wifi-iface[0].mode )" in
			adhoc)
				return 1
			;;
			sta)
				return 1	# fixme! workaround for uci-wrapper
			;;
			*)
				return 0
			;;
		esac
	else
		eval "$( _wifi params_iwconfig_status $WIFI_DEV | grep ^WIFI_MODE= )"

		case $WIFI_MODE in
			Managed|managed|Master|master) return 0 ;;
						    *) return 1 ;;
		esac
	fi
}

_wifi_probe_mode_ap ()				# fixme! respect WIFI_DEV
{
	local funcname="wifi_probe_mode_ap"
	local WIFI_DEV="$1"
	local SWITCH="$2"	# 'config' or <empty>
	local WIFI_MODE

	if [ "$SWITCH" = "config" ]; then

		if [ "$( uci get wireless.@wifi-iface[0].mode )" = "ap" ]; then
			return 0
		else
			return 1
		fi
	else
		eval "$( _wifi params_iwconfig_status $WIFI_DEV | grep ^WIFI_MODE= )"

		case $WIFI_MODE in
			Master|master)
				return 0
			;;
			Managed|managed)
				return 1
			;;
			Ad-Hoc)
				return 1
			;;
			*)
				_log do $funcname daemon info "unknown mode '$WIFI_MODE'"
				return 1
			;;
		esac
	fi
}

_wifi_mode ()			# OUT1: string, ap | client | adhoc             // rename: wifi_get_mode_conn?
{
	local funcname="wifi_mode"
	local WIFI_DEV="$1"	# fixme! some calls can't provide wifidev - till now we only check nvram, so it does'nt matter
	local SWITCH="$2"	# can be 'config' or <empty>

	fgrep -q "${WIFI_DEV:-no_wifi}:" /proc/net/dev || {
		_log do $funcname daemon debug "wifidev ${WIFI_DEV:-no_wifi} not found"
		return 1
	}

	local mode1="$( uci get wireless.@wifi-iface[0].mode )"
	local mode2="$( uci get wireless.@wifi-iface[1].mode )"

	case "$mode1" in
		ap|adhoc)
			case "$mode2" in
				ap|adhoc)
					echo "${mode1}${mode2}"		# fixme! we dont diff between config/real
					return				# fixes e.g. compare_config_and_real_wifi_mode() in watch()
				;;
			esac
		;;
	esac

	if _wifi probe_mode_infrastructure $WIFI_DEV "$SWITCH" ; then
	
		if _wifi probe_mode_ap $WIFI_DEV "$SWITCH" ; then
			echo 'ap'
		else
			echo 'client'	# fixme! output 'sta' or 'station' ?
		fi
	else
		if _wifi probe_mode_ap $WIFI_DEV "$SWITCH" ; then
			echo 'unknown'	
		else
			echo 'adhoc'
		fi
	fi
}

_wifi_check_each_client()
{
	local mac ip list_macs exitcode list_already_known_macs local up1 up2 up_diff
	local funcname="wifi_check_each_client"
	local max_arping="10"
	local statsdir="/tmp/$funcname"

	mkdir -p "$statsdir"
	_net include

	list_macs="$( iw dev $WIFIDEV station dump | grep ^Station | cut -d' ' -f2 )"

	for mac in $list_macs; do {		# fixme! only check client with low inactivity time
		[ "$exitcode" = "0" ] || {
			ip="$( _net mac2ip $mac )" && {
				if arping -q -f -c $max_arping -I $WIFIDEV $ip ; then
					_log do $funcname daemon debug "[OK] arping - mac: $mac ip: $ip"
					exitcode="0"
				else
					_log do $funcname daemon info "[ERR] arping - mac: $mac ip: $ip (no success for $max_arping probes)"
					# iw dev "$WIFIDEV" station del "$mac"
					exitcode="1"
				fi
			}
		}

		[ -e "$statsdir/$mac" ] || {
			_log do $funcname daemon info "[OK] detected new station $mac"
			_system uptime >"$statsdir/$mac"
		}
	} done

	station_is_valid()
	{
		iw dev $WIFIDEV station get "${1:-unset}" 2>/dev/null >/dev/null
	}

	list_already_known_macs="$( ls -1 "$statsdir" 2>/dev/null )"

	for mac in $list_already_known_macs; do {		# fixme! writeout traffic_counter
		station_is_valid "$mac" || {
			up2="$( _system uptime )"
			read up1 <"$statsdir/$mac"
			rm "$statsdir/$mac"
			up_diff="$(( $up2 - $up1 ))"

			_log do $funcname daemon alert "[OK] station $mac left network $WIFIDEV, ($( _stopwatch seconds2humanreadable $up_diff ))"
		}
	} done

	return ${exitcode:-0}
}
