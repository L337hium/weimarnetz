#!/bin/sh
. /tmp/loader

fkt_build_settings_menu ()				# SENS: switching between "simple", "expert" and "full" settings-menu
{							# ARG1: string, "simple", "expert", "full" or "" (empty)
	local DAEMON="fkt_build_settings_menu"
	local MODE="$1"	
	local DEST="/www/cgi-bin"
	local ID="15"
	local ID_EXPERT="16"
	local ID_USER="17"
	local FILE="config_fff+"
	local OPT_EXPERT="gui=expert"
	local OPT_USER="gui=user"
	local TITLE="Schnelleinstellung"
	local TITLE_EXPERT="Experteneinstellung"
	local TITLE_USER="Benutzerverwaltung"
	local MENU="$( uci get system.@webadmin[0].menu )"

	test -n "$READONLY" && return
	test -n "$FAILSAFE" && return
	
	_log do "$DAEMON" daemon debug "nvram is '$MENU', wish is '$MODE'"
	test ! -z "$MODE" && MENU=$MODE
	_log do "$DAEMON" daemon debug "Trying to establish mode '$MENU'"

	if [ -n "$FAILSAFE" ] || _system flash_mounted_readonly ; then
		_log do "$DAEMON" daemon debug "No action in failsafe/readonly mode possible!"
		return
	fi

	cd $DEST

	if [ ! -e "$ID-$FILE" ]; then
		_log do "$DAEMON" daemon debug "Inserting settings-menu entry"
		echo >$ID-$FILE "<TR ID=\"idx-$ID\"><TD><DIV CLASS=\"plugin\"><A CLASS=\"plugin\" HREF=\"$FILE\">$TITLE</A></DIV></TD></TR>"
	else
		_log do "$DAEMON" daemon debug "Settings-menu entry already exists"
	fi

	if [ "$MENU" = "simple" ] || [ -z "$MENU" ]; then
		_log do "$DAEMON" daemon debug "Checking if simple menu is up to date"

		test -e "$ID_EXPERT-$FILE" && mv "$ID_EXPERT-$FILE" "ghosted_$ID_EXPERT-$FILE"
		test -e "$ID_USER-$FILE"   && mv "$ID_USER-$FILE"   "ghosted_$ID_USER-$FILE"
	
		local LIST="$(ls -1 [^a-z]*)"
		for OBJ in $LIST; do
			if [ "$OBJ" != "$ID-$FILE" ]; then
				_log do "$DAEMON" daemon debug "Moving $DEST/$OBJ to $DEST/ghosted_$OBJ"
				mv "$OBJ" "ghosted_$OBJ"
			fi
		done
	fi
	
	if [ "$MENU" = "expert" ]; then
		_log do "$DAEMON" daemon debug "Checking if expert menu is up to date"

		local LIST="$(ls -1 [^a-z]*)"
		for OBJ in $LIST; do
			if [ "$OBJ" != "$ID-$FILE" ]; then
				_log do "$DAEMON" daemon debug "Moving $DEST/$OBJ to $DEST/ghosted_$OBJ"
				mv "$OBJ" "ghosted_$OBJ"
			fi
		done
	fi
	
	if [ "$MENU" = "expert" ] || [ "$MENU" = "full" ]; then
		if [ ! -e "$ID_EXPERT-$FILE" ]; then
			_log do "$DAEMON" daemon debug "Inserting expert-settings-menu entry"
			echo >$ID_EXPERT-$FILE "<TR ID=\"idx-$ID\"><TD><DIV CLASS=\"plugin\"><A CLASS=\"plugin\" HREF=\"$FILE?$OPT_EXPERT\">$TITLE_EXPERT</A></DIV></TD></TR>"
		else
			_log do "$DAEMON" daemon debug "Expert-settings-menu entry already exists"
		fi	
		
		if [ ! -e "$ID_USER-$FILE" ]; then
			_log do "$DAEMON" daemon debug "Inserting user-settings-menu entry"
			echo >$ID_USER-$FILE "<TR ID=\"idx-$ID\"><TD><DIV CLASS=\"plugin\"><A CLASS=\"plugin\" HREF=\"$FILE?$OPT_USER\">$TITLE_USER</A></DIV></TD></TR>"
		else
			_log do "$DAEMON" daemon debug "User-settings-menu entry already exists"
		fi
	fi

	if [ "$MENU" = "full" ]; then
		_log do "$DAEMON" daemon debug "Checking if full menu is up to date"
		
		local LIST="$(ls -1 ghosted_* 2>/dev/null)"
		for OBJ in $LIST; do
			local OBJ_NEW="$(echo $OBJ | sed "s/ghosted_//g")"
			_log do "$DAEMON" daemon debug "Moving $DEST/$OBJ to $DEST/$OBJ_NEW"
			mv "$OBJ" "$OBJ_NEW"
		done
	fi
	
	[ -e "$ID_EXPERT-$FILE" ] && rm "$ID_EXPERT-$FILE"	# fixme!
}

fkt_patch ()
{
	local  FNAME="patch"
	local  PATCH="$1"					# ARG1: string (keyword, what todo)
	local   MODE="$2"					# ARG2: string (optional, keyword "restore_from_rom")
	local   TEMP="/tmp/$FNAME"
	local BACKUP="${TEMP}_backup"
	local   SIZE=0
	local   FILE=0

	_log do $FNAME daemon info "found newstyle-device, ignoring call for patching '$PATCH' ($MODE)"
	return							# fixme! function was built for oldstyle devices

}

fkt_generate_logread_replacement () {
	local FNAME="generate_logread_replacement"
	local  FILE="/usr/bin/logread.sh"

	_log do $FNAME daemon info "creating $FILE"

	cat >$FILE <<EOF
#!/bin/sh

# this file was generating trough $0 (fkt_generate_logread_replacement)

  if [ -e "/var/log/messages" ] && [ "\$1" = "-f" ]; then
	echo "+ exec \"tail -n 50 -f /var/log/messages\"  (showing last 50 lines and further):"
	echo
	tail -n 50 -f /var/log/messages

elif [ -e "/var/log/messages" ] && [ "\$1" = "-a" ]; then
	echo "exec \"cat /var/log/messages.0 /var/log/messages\" (showing whole syslog):"
	echo
	cat /var/log/messages.0 /var/log/messages 2>/dev/null

elif [ -e "/var/log/messages" ]; then
	echo "exec \"tail -n 300 /var/log/messages\" (showing last 300 syslog lines) - look <a href=\"cgi-bin-tool_fff+?GREP=%3A&OPT=syslog&GUI=1&SUPRESS1=DHCP&SUPRESS2=rrdcollect&HIGHLIGHT=fff\">here for whole syslog</a> or use \"logread.sh -a\"..."
	echo
	tail -n 300 /var/log/messages
else
	echo "no syslog available yet! try 'logread'"
fi
EOF

	chmod +x "$FILE"	
	ln -s "$FILE" /usr/bin/lr
}

func_print_pagepeel () {			# first line is for "schaeuble"-head

	cat >>$TEMP <<EOF
<script type="text/javascript" src="watching.js"></script>

<!-- AKVS head start v1.5 -->
<style type="text/css">
<!--
div#akct {
	position: absolute; top:0px; right: 0px; z-index: 2342; width:113px; height:88px;
	background-image: url(http://wiki.vorratsdatenspeicherung.de/images/Akvse.gif);
	background-repeat: no-repeat;
	background-position: right top;
	border:none;
	padding:0;
	margin:0;
	text-align: right;
}

div#akct img {
	border:none;
	padding:0;
	margin:0;
	background: none;
}

div#akct a#akpeel img {
        width: 113px;
        height: 88px;
}

div#akct a, div#akct a:hover {
	text-decoration: none;
	border:none;
	padding:0;
	margin:0;
	display: block;
	background: none;
}

div#akct a#akpeel:hover {
	position: absolute; top:0px; right: 0px; z-index: 4223; width:500px; height:500px;
	display: block;
	background-image: url(http://wiki.vorratsdatenspeicherung.de/images/Akvsb.gif);
	background-repeat: no-repeat;
	background-position: right top;
}

div#akct a#akpreload {
	background-image: url(http://wiki.vorratsdatenspeicherung.de/images/Akvsb.gif);
	background-repeat: no-repeat;
	background-position: 234px 0px;
}
-->
</style>
<!--[if gte IE 5.5]>
<![if lt IE 7]>
<style type="text/css">
div#akct a#akpeel:hover {
		right: -1px;
}
</style>
<![endif]>
<![endif]-->
<!-- AKVS head end -->

</HEAD>
<BODY>
<!-- AKVS body start v1.5 -->
<div id="akct"><a id="akpeel" href="http://www.vorratsdatenspeicherung.de" target="_blank" title="Stoppt die Vorratsdatenspeicherung! Jetzt klicken &amp; handeln!"><img src="http://wiki.vorratsdatenspeicherung.de/images/Akvst.gif" alt="Stoppt die Vorratsdatenspeicherung! Jetzt klicken &amp; handeln!" /></a><a id="akpreload" href="http://wiki.vorratsdatenspeicherung.de/?title=Online_Demo" target="_blank" title="Willst du auch bei der Aktion teilnehmen? Hier findest du alle relevanten Infos und Materialien:"><img src="http://wiki.vorratsdatenspeicherung.de/images/Akvsi.gif" alt="Willst du auch bei der Aktion teilnehmen? Hier findest du alle relevanten Infos und Materialien:" /></a></div>
<!-- AKVS body end -->
EOF
}

fkt_gen_infos_for_login_banner ()		# fixme! rewrite on every boot
{
	eval $( /etc/init.d/S02check_interface_correctness_fff+ show_hardware )

	local HW="$( echo "$HW" | sed 's/)//' )"
	local URL_FIRMWARE_DOWNLOAD="$( _links firmware_url_get )"
	
	cat <<EOF
$(tail -n 2 /etc/variables_fff+)
FLASHDATE=$( date +%Y%h%d-%H:%M )
UPDATEMODE=$( _firmware updatemode )
INETOFFER=$( _net local_inet_offer )
PROFILE=$( uci get system.@profile[0].name )
FF_RELEASE=$( _system version short )

Node: $( uci get system.@profile[0].nodenumber ) | Hardware: $HW @ $( _wifi phy_txpower $WIFIDEV mw )mW) | RAM/FLASH: $(_system ram_size)/$( _system flash_size )kb | USB: $USB | IDE: $IDE | miniPCI: $MINIPCI

Hints: - 'lr -f OR logread.sh -f' is short for 'tail -n 50 -f /var/log/messages'
       - 'neigh.sh', 'hna.sh' or 'neigh' gives olsrd-feedback
       - '/usr/sbin/fwupload_fff+' starts upload of own changes to SVN/GIT-server
       - '/etc/init.d/S01firmware_update_fff+ check' for safe flashing
       - '/etc/init.d/S01firmware_update_fff+ poor_mens_update' for fast'n'dirty update and
       - 'wget -O fw.trx "$URL_FIRMWARE_DOWNLOAD"' +
         'firmware-burn fw.trx' is for fast flashing

EOF
}

fkt_patch_intro_picture ()
{
	local FUNC="patch_intro_picture"
	local WIKI_MAIN_URL="http://wireless.subsignal.org"
	
	local PICTURE_NAME="Node$( uci get system.@profile[0].nodenumber ).jpg"		# searching for a picture in wiki name Node324.jpg (for node 324)
	local PICTURE_URL="${WIKI_MAIN_URL}/index.php?title=Bild:$PICTURE_NAME"		# path for wiki-picture-page (with description etc.)
	local PICTURE_FILE="/www/images/intro.jpg"
	local PICTURE_LINK
	
	PICTURE_LINK="$( _wget do "$PICTURE_URL" 30 |
		grep "$PICTURE_NAME" |
		 sed -n "s/.*href=\"\(.*$PICTURE_NAME\)\".*/\1/p" |
		  head -n2 |
		   tail -n1 |
		    cut -d'"' -f1
	)"

	echo $PICTURE_LINK | grep -q "^http://" || {		# no picture for this node uploaded on wiki yet
		PICTURE_URL="${WIKI_MAIN_URL}${PICTURE_LINK}"	# node-specific-picture
	
		_log do $FUNC daemon info "from '$PICTURE_URL'"
	                                                                                
		_wget do "$PICTURE_URL" 60 >"$PICTURE_FILE"
	}
}

_call_start ()							# after reach reboot
{		# fkt_patch syslog_with_rebootfix_syslog	# fixme! /var/log/messages is first started at S10boot, use /www/everlasting_syslog.txt
		fkt_build_settings_menu				# only needed for generating menu-entrys

		_watch counter /www/REBOOT_COUNTER increment

       		grep -sq "kern.warn kernel: " /www/everlasting_syslog.txt && {
       			_log do detect_old_oops daemon alert "kernel-oops detected"
		}

		[ ! -e "/www/FRESHFLASHED" ] && {		# we must take care of the
			rm -f "$LOCKFILE"			# lockfile, each time we exit
			_call_virgin				# or recall this script, otherwise
		}						# it won't work out ;-)

		# [ "$( _wifi mode )" != "adhoc" ] && {			# fixme! and the way back to normal wifi-olsr?
		#							# fixme! an olsr-feature was found, needs some research
		#	case "$( uci get system.@profile[0].name )" in	# does not work: iptables -I OUTPUT -p udp --dport 698 -j DROP
		#		versilia_ap)				#     -> syslog: kern.err olsrd[32119]: OLSR: sendto IPv4 Operation not permitted
		#			exit
		#		;;
		#		versilia_client)
		#			exit
		#		;;
		#		*)
		#			fkt_patch olsrd_not_on_wifi
		#		;;
		#	esac
		# }
}

_call_patch ()
{
	local PATCHLIST="$@"
	local PATCH
	
	for PATCH in $PATCHLIST; do {
		fkt_patch "$PATCH"
	} done
}

_call_repatch ()
{
	local OPTION="$1"

	case "$OPTION" in
		all)
			_call_restore_from_rom
			_call_virgin
			rm /www/FRESHFLASHED		# no start for software-install
			_call_post_software_install
			fkt_build_settings_menu		# is a hack for '$0 start'
			touch /www/FRESHFLASHED		# fixme! otherwise the profile_enforcer runs
		;;
		*)
			_call_restore_from_rom "$OPTION"
			_call_patch "$OPTION"
		;;
	esac
}

_call_virgin ()							# after virgin boot (directly after flashing)
{
		PATCHLIST="syslogd_start_for_more_space \
			   remove_oldstyle_cron \
			   hide_all_repos \
			   syslogd_set_hostname \
			   force_olsrd_startup_without_wifi \
			   statuspage_for_new_syslog \
			   cron_minutely_for_verboser_trace_errors \
			   cron_minutely_for_verboser_hna_on \
			   cron_minutely_for_configureable_tracetest \
			   http_public_menu_entry \
			   fancy_prompt \
			   fancy_myssh \
			   leds_off"
		
		for PATCH in $PATCHLIST; do {
			fkt_patch $PATCH
		} done
		
		fkt_generate_logread_replacement
		
		touch "/www/FRESHFLASHED"
}

_call_post_software_install ()					# is invoked directly after ready software_install
{
		PATCHLIST="olsrd_timezone_and_restart_counter \
			   dnsserver_timezone \
			   dnsserver_fast_lease \
			   syslog_start_timezone \
			   httpd_start_for_own_404page \
			   admin_start_page_for_own_values \
			   proxy_start_for_changing_port \
			   login_banner \
			   owfs_activate_server_option_for_usb \
			   owfs_activate_server \
			   rrd_txpwr_collect \
			   rrd_txpwr_conf \
			   rrd_txpwr_exec \
			   cron_minutely_for_welcome_helper \
			   html_preprocessor_with_pagepeel_and_nodenumber_in_title"
	
		for PATCH in $PATCHLIST; do {
			fkt_patch $PATCH
		} done
		
		uci get system.@profile[0].name | grep -q ^weimarnetz && {
			fkt_patch_intro_picture
		}
}

_call_restore_from_rom ()
{
	local PATCHLIST="$1"

	[ -z "$PATCHLIST" ] && {
		PATCHLIST="owfs_activate_server \
			   olsrd_timezone_and_restart_counter \
			   dnsserver_timezone \
			   syslog_with_rebootfix_syslog \
			   force_olsrd_startup_without_wifi \
			   statuspage_for_new_syslog \
			   syslogd_start_for_more_space \
			   admin_start_page_for_own_values \
			   httpd_start_for_own_404page \
			   proxy_start_for_changing_port \
			   cron_minutely_for_verboser_trace_errors \
			   login_banner \
			   intro_picture \
			   html_preprocessor_with_pagepeel_and_nodenumber_in_title \
			   http_public_menu_entry \
			   fancy_prompt"
	}

	for PATCH in $PATCHLIST; do {
		fkt_patch $PATCH restore_from_rom
	} done
	
	rm -f "/www/FRESHFLASHED"
}

_call_usage ()
{
		echo "Usage: $0 ( start | virgin | post_software_install | restore_from_rom | patch <PATCHNAME> | repatch <PATCHNAME|all )"
}


if [ -n "$1" ]; then
	if [ -n "$FAILSAFE" ] || [ -n "$READONLY" ]; then exit; fi
fi

LOCKFILE="/tmp/lockfile_patch-o-matic"

if [ -e "$LOCKFILE" ]; then
	_log do check_lockfile daemon crit "lockfile '$LOCKFILE' exists - abort"
	exit
else
	touch "$LOCKFILE"
fi

MAC_CHANGE="/www/mac_changed.txt"


case "$1" in
	start|virgin|post_software_install|restore_from_rom|patch|repatch)
		ARG1="$1"; shift; _call_$ARG1 "$@"
	;;
	*)
		_call_usage
	;;
esac


rm -f "$LOCKFILE"

